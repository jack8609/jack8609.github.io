<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>違規檢舉小幫手</title>

  <!-- ✅ COI Service Worker（需同源 HTTP 伺服器；不可 file://） -->
  <script src="./coi-serviceworker.min.js"></script>

  <!-- 避免 favicon 404 -->
  <link rel="icon" href="data:," />

  <style>
    /* =========================================================
       Base & Theme Variables
       ========================================================= */
    :root {
      /* 雙滑桿尺寸 */
      --rail-pad: 14px;
      --track-height: 8px;
      --thumb-size: 18px;
      --spacing-v: 18px;
    
      /* 深色主題（預設） */
      --bg: #0e0f12;
      --fg: #e6e6e6;
      --panel: #16181d;
      --border: #262a33;
    
      /* 雙滑桿顏色（深色） */
      --track-bg: #16181d;
      --select-bg: #1e6fd6;
      --accent-color: #35a0ff;
    
      /* 元件色彩 */
      --log-bg: #0a0a0a;
      --log-fg: #86ff91;
      --chip-bg: #0f2338;
      --chip-fg: #bfe3ff;
      --chip-border: #1f3d5e;
      --link-color: #8fbfff;
      --btn-border: var(--border);
      --btn-bg: var(--panel);
      --btn-fg: var(--fg);
      --btn-primary-bg: #0c3a60;
      --btn-primary-fg: #ffffff;
      --btn-primary-border: var(--accent-color);
      --btn-hover-bg: #222833;
    
      /* 次要文字 */
      --muted-fg: #9aa5b1;
    
      /* 可及性焦點色 */
      --focus-ring: #1e6fd6;
      --focus-ring-light: #2563eb;
      --focus-shadow-alpha: 0.22;
    
      /* 內容最大寬（可依需求調整） */
      --content-max: 960px;
    }
    html { color-scheme: dark light; }

    /* =========================================================
       Light Theme Overrides
       ========================================================= */
    html[data-theme="light"] {
      --bg: #f6f7f9;
      --fg: #111827;
      --panel: #ffffff;
      --border: #d1d5db;
      --track-bg: #ffffff;
      --select-bg: #2563eb;
      --accent-color: #2563eb;
      --log-bg: #f8fafc;
      --log-fg: #0f766e;
      --chip-bg: #e6f0ff;
      --chip-fg: #0b3b77;
      --chip-border: #bfd3ff;
      --link-color: #2563eb;
      --btn-primary-bg: #1d4ed8;
      --btn-primary-border: #1d4ed8;
      --btn-hover-bg: #eef2f7;
      --muted-fg: #6b7280;
      --focus-ring: var(--focus-ring-light);
    }
    
    /* =========================================================
       Theme Toggle
       ========================================================= */
    .theme-toggle input[type="checkbox"] {
      appearance: none;
      width: 30px; height: 10px;
      border-radius: 999px;
      background: #9aa5b1;
      position: relative;
      outline: none;
      cursor: pointer;
      transition: background .2s ease;
      border: 0px solid var(--border);
    }
    .theme-toggle input[type="checkbox"]::after {
      content: "";
      position: absolute;
      top: -4px; left: 0px;
      width: 18px; height: 18px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0,0,0,.2);
      transition: transform .2s ease;
    }
    .theme-toggle input[type="checkbox"]:checked { background: var(--accent-color); }
    .theme-toggle input[type="checkbox"]:checked::after { transform: translateX(18px); }
    .theme-toggle .label { font-size: clamp(10px, 4vw, 13px);; color: inherit; }
    @supports (-webkit-touch-callout: none) {
      .theme-toggle { margin-top: calc(env(safe-area-inset-top) + 8px); }
    }

    /* 父容器：建立定位上下文，並預留右側空間以免 h1 碰到開關 */
    .page-title-bar {
      position: relative;         /* 讓內部 absolute 以此為座標 */
      padding-right: 120px;       /* 預留空間（依你的開關寬度調整） */
      /* 可選：上下留點餘裕 */
      padding-top: 8px;
      padding-bottom: 8px;
    }
    
    /* 標題本身可在窄螢幕換行，避免碰撞 */
    .page-title-bar h1 {
      margin: 0;
      font-weight: 800;
      color: var(--fg);
      white-space: normal;
      overflow-wrap: anywhere;    /* 換行以避免碰到右側開關 */
    }
    
    /* 開關固定在右上角但跟著捲動（因為相對 parent） */
    .page-title-bar .theme-toggle {
      position: absolute;
      top: 50%;
      right: 0px;
      transform: translateY(-70%);  /* 垂直置中；若要貼頂改成 top: 0 即可 */
      z-index: 10;
    
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--fg);
      border-radius: 999px;
      padding: 6px 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,.08);
    }
    
    /* 窄螢幕時縮小右側預留空間與字級，降低碰撞機率 */
    @media (max-width: 420px) {
      .page-title-bar { padding-right: 96px; }
      .page-title-bar h1 { font-size: clamp(16px, 4vw, 24px); }
      .page-title-bar .theme-toggle { right: 0px; }
    }
    
    /* iOS 安全區：避免貼到瀏海或側邊曲面 */
    @supports (-webkit-touch-callout: none) {
      .page-title-bar {
        padding-right: calc(96px + env(safe-area-inset-right));
        padding-top: calc(8px + env(safe-area-inset-top));
      }
    }
    /* =========================================================
       Violation Editor（整合）
       ========================================================= */
    .violation-editor * { box-sizing: border-box; }
    .violation-editor {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial, "PingFang TC", "Microsoft JhengHei", sans-serif;
      color: var(--fg);
      background: var(--panel);
      line-height: 1.5;
      width: min(100%, var(--content-max));
      margin-inline: auto;
      max-width: 100%;
      overflow-x: hidden;
    }
    .violation-editor .toolbar {
      display: flex; flex-wrap: wrap; gap: 10px 14px; align-items: center;
      border: 1px solid var(--border); padding: 12px; border-radius: 6px; background: var(--panel);
      max-width: 100%; overflow: hidden;
    }
    .violation-editor .group { display: inline-flex; align-items: center; gap: 8px; flex: 0 1 auto; min-width: 0; }
    @media (max-width: 640px) { .violation-editor .group.full { flex-basis: 100%; } }
    .violation-editor label { font-size: 14px; color: var(--muted-fg); white-space: nowrap; flex: 0 0 auto; }
    .violation-editor input[type="text"],
    .violation-editor input[type="date"],
    .violation-editor select,
    .violation-editor textarea,
    .violation-editor button {
      border: 1px solid var(--border);
      padding: 6px 8px; font-size: 14px; border-radius: 6px;
      background: var(--panel); color: var(--fg); outline: none;
      min-width: 0; max-width: 100%; box-sizing: border-box;
    }
    .violation-editor :is(input, select, textarea, button):focus-visible {
      border-color: var(--focus-ring);
      box-shadow: 0 0 0 3px rgba(30, 111, 214, var(--focus-shadow-alpha));
    }
    
    /* 車牌輸入框 */
    .violation-editor #ve-plate1, .violation-editor #ve-plate2 { width: 80px; }
    .violation-editor .plate-boxes { display: inline-flex; gap: 8px; align-items: center; min-width: 0; }
    .violation-editor .dash { color: var(--muted-fg); user-select: none; }
    
    /* 時間下拉 */
    .violation-editor .time-selects { display: inline-flex; gap: 8px; align-items: center; min-width: 0; }
    .violation-editor .time-selects select { min-width: 80px; }
    
    /* 預覽／輸出 */
    .violation-editor .preview {
      margin-top: 14px; border: 1px solid var(--border); padding: 12px;
      background: var(--panel); border-radius: 6px; max-width: 100%; overflow: hidden;
    }
    .violation-editor textarea#ve-output {
      width: 100%; height: 140px; font-size: 18px; font-weight: 700;
      border: none; background: transparent; resize: vertical; line-height: 1.7; box-sizing: border-box;
    }
    
    /* 控制列與按鈕 */
    .violation-editor .control-row { display: flex; align-items: center; gap: 12px; margin-top: 8px; flex-wrap: wrap; min-width: 0; }
    .violation-editor .btn { background: var(--panel); color: var(--fg); border-color: var(--border); cursor: pointer; }
    .violation-editor .btn:hover { background: var(--btn-hover-bg); border-color: var(--btn-primary-border); }
    
    /* Light 覆寫（提高對比） */
    html[data-theme="light"] .violation-editor label { color: var(--fg); }
    html[data-theme="light"] .violation-editor input[type="text"],
    html[data-theme="light"] .violation-editor input[type="date"],
    html[data-theme="light"] .violation-editor select,
    html[data-theme="light"] .violation-editor textarea,
    html[data-theme="light"] .violation-editor button {
      background: #ffffff; color: var(--fg); border-color: var(--border);
    }
    html[data-theme="light"] .violation-editor .btn:hover { background: var(--btn-hover-bg); border-color: #bfd3ff; }
    
    /* Select（長字串與 iOS 外觀修正） */
    .violation-editor select {
      -webkit-appearance: none; appearance: none;
      background: var(--panel); color: var(--fg); border: 1px solid var(--border);
      width: 100%; max-width: 100%; box-sizing: border-box;
      white-space: normal; text-overflow: ellipsis; overflow: hidden;
    }
    .violation-editor option { background: var(--panel); color: var(--fg); }
    html[data-theme="light"] .violation-editor select { background: #fff; color: var(--fg); border-color: var(--border); }
    html[data-theme="light"] .violation-editor option { background: #fff; color: var(--fg); }

    /* 違規項目列：左短右長 */
    .violation-editor .violation-row {
      display: flex;
      gap: 8px;
      align-items: center;
      min-width: 0;
    }
    
    .violation-editor #city-select {
      flex: 0 0 auto;
      /* 三～四個中文字寬 + 內距、邊框：你可微調為 6em / 96px / 8ch */
      width: 6.5em;          /* 約等於「台中市」寬度 + 些微空間 */
      max-width: 40%;
    }
    
    .violation-editor #ve-violation {
      flex: 1 1 auto;        /* 吃滿剩餘寬度 */
      min-width: 0;          /* 讓文字可縮、避免溢出 */
    }
    
    /* 小螢幕時縣市再短一點，避免擠壓 */
    @media (max-width: 420px) {
      .violation-editor #city-select { width: 5.5em; }
    }

    /* =========================================================
       Global Base & Components
       ========================================================= */
    * { box-sizing: border-box; }
    body {
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto;
      margin: 2rem;
    }
    @media (max-width: 480px) { body { margin: 1rem; } }
    h1 { margin-top: 0; }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1rem;
    }
    .controls { display: flex; align-items: center; gap: .5rem; flex-wrap: wrap; }
    .log {
      white-space: pre-wrap; background: var(--log-bg); color: var(--log-fg);
      padding: 1rem; min-height: 10rem; border-radius: 8px; font-size: 0.92rem;
    }
    button {
      padding: .55rem .85rem; border-radius: 8px;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg); color: var(--btn-fg);
      cursor: pointer;
    }
    button:disabled { opacity: .6; cursor: not-allowed; }
    button.primary { border-color: var(--btn-primary-border); color: var(--btn-primary-fg); background: var(--btn-primary-bg); }
    .status { margin:.5rem 0; }
    .time { font-variant-numeric: tabular-nums; }
    .chip {
      background: var(--chip-bg); color: var(--chip-fg);
      border: 1px solid var(--chip-border); padding: .2rem .5rem; border-radius: 6px;
    }
    a { color: var(--link-color); }
    .hint { background: var(--panel); color: var(--fg); font-size: .9rem; }
    .col { display: grid; grid-template-columns: 1fr; gap: 1rem; }
    @media (min-width: 980px) { .col { grid-template-columns: 1.2fr 1fr; } }
    /* 標題顏色 */
    .group-title { margin: .5rem 0 .25rem; font-weight: 600; color: #c9d1d9; }
    html[data-theme="light"] .group-title { color: var(--fg); }

    /* =========================================================
       Media Area & Stacked Slider
       ========================================================= */
    .media-area { padding: 0 var(--rail-pad); }
    .media-area video {
      width: 100%; max-width: 100%; display: block; background: #000; border-radius: 8px;
    }

    .stacked-slider { position: relative; margin-top: .75rem; }
    .stacked-slider .rail {
      position: relative;
      height: calc(var(--spacing-v) * 2 + var(--track-height));
      padding: 0;
    }
    .stacked-slider .track {
      position: absolute; left: 0; right: 0;
      height: var(--track-height); background: var(--track-bg); border-radius: 6px;
    }
    .stacked-slider .track.top { top: 0; }
    .stacked-slider .track.bottom { top: calc(var(--spacing-v) + var(--track-height)); }
    .stacked-slider .selection {
      position: absolute;
      top: calc(var(--spacing-v) / 2 + var(--track-height) / 2);
      height: var(--track-height); background: var(--select-bg);
      border-radius: 6px; pointer-events: none;
    }
    .stacked-slider input[type="range"] {
      position: absolute; left: 0; right: 0; width: 100%;
      margin: 0; background: transparent; -webkit-appearance: none; appearance: none;
      cursor: pointer; height: var(--spacing-v);
    }
    .stacked-slider #startRange { top: 0; }
    .stacked-slider #endRange   { top: var(--spacing-v); }
    .stacked-slider input[type="range"]::-webkit-slider-runnable-track { height: var(--track-height); background: transparent; }
    .stacked-slider input[type="range"]::-moz-range-track { height: var(--track-height); background: transparent; }
    .stacked-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none;
      width: var(--thumb-size); height: var(--thumb-size);
      border-radius: 50%; background: var(--accent-color);
      border: 2px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      margin-top: calc(var(--track-height) / 2 - var(--thumb-size) / 2);
    }
    .stacked-slider input[type="range"]::-moz-range-thumb {
      width: var(--thumb-size); height: var(--thumb-size);
      border-radius: 50%; background: var(--accent-color);
      border: 2px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .stacked-slider input[type="range"]:focus-visible {
      outline: none; box-shadow: 0 0 0 3px rgba(30, 111, 214, var(--focus-shadow-alpha));
    }

    /* Log 折疊控制 */
    .log-panel { display: none; }
    .log-panel.show { display: block; }

    /* =========================================================
       Shot Preview & Generated Items
       ========================================================= */
    /* 主體不再強制修補直式白區（由 EditorLite 注入樣式已修正） */
    .shot-box { display: grid; grid-template-columns: 1fr; gap: .75rem; }
    .shot-preview {
      background: var(--panel); border: 1px solid var(--border);
      min-height: 260px; /* 供桌面端，直式具體高度由 EditorLite 斷點接管 */
      min-width: 100%;
      display: flex; align-items: center; justify-content: center;
      border-radius: 8px; overflow: auto; max-width: 100%;
    }
    .shot-preview img { max-width: 100%; height: auto; display: block; }

    /* =========================================================
       RWD（包含 iPhone 兩欄按鈕）
       ========================================================= */
    @media (max-width: 840px) {
      #shotPreview .editor-grid { grid-template-columns: 1fr; gap: 12px; }
      #shotPreview .tool-row { display: flex; flex-wrap: wrap; gap: 8px; min-width: 0; }
      #shotPreview .tool-row .btn {
        flex: 1 1 calc(50% - 8px); /* 手機預設兩欄 */
        min-width: 140px;
        text-align: center;
      }
      #shotPreview .plate-preview {
        display: flex; flex-direction: column; gap: 10px; padding: 10px;
        background: var(--panel); border: 1px dashed var(--border); border-radius: 8px;
        max-width: 100%; overflow-x: hidden;
      }
      #shotPreview .plate-preview .row { width: 100%; display: flex; align-items: center; gap: 8px; min-width: 0; }
      #shotPreview .plate-preview select, #shotPreview .plate-preview input[type="range"] { flex: 1 1 auto; min-width: 0; }
      #shotPreview .plate-preview img { max-width: 180px; height: auto; }
      #shotPreview #drawingOptionsContainer {
        display: flex; flex-direction: column; gap: 10px;
        background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 10px;
        max-width: 100%; overflow-x: hidden;
      }
      #shotPreview #drawingOptionsContainer .row { width: 100%; display: flex; align-items: center; gap: 8px; min-width: 0; }
      #shotPreview #drawingOptionsContainer select, #shotPreview #drawingOptionsContainer input[type="range"] { flex: 1 1 auto; min-width: 0; }
      #shotPreview .editor-stage { padding: 8px; }
      #staticImageContainer { width: 100%; max-width: 100%; overflow: hidden; }
      #staticImage { max-width: 100%; height: auto; display: block; }
      #shotPreview .editor-stage #drawingOverlay { left: 0; top: 0; width: 100%; height: auto; max-width: 100%; }
      #shotPreview .editor-right {
        max-height: 100%; padding: 10px; background: var(--panel);
        border: 1px solid var(--border); border-radius: 8px; max-width: 100%; overflow-x: hidden;
      }
      #shotPreview #generatedImagesArea { overflow: visible; }
      #shotPreview .generated-image-card { background: var(--panel); border-color: var(--border); border-radius: 8px; padding: 8px; }
      #shotPreview .generated-image-card .inner { background: var(--panel); border-color: var(--border); border-radius: 6px; padding: 6px; }
      #shotPreview .generated-image-card .header { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; min-width: 0; }
      #shotPreview .generated-image-card .btn-row { display: flex; gap: 8px; margin-left: auto; }
      #shotPreview .generated-image-card img { width: 100%; height: auto; display: block; }
    }

    /* iPhone 常見寬度：維持兩欄；超窄退單欄 */
    @media (max-width: 420px) {
      #shotPreview .tool-row { display: flex; flex-wrap: wrap; gap: 8px; overflow: hidden; }
      #shotPreview .tool-row .btn {
        flex: 1 1 calc(50% - 8px);
        min-width: 0; width: auto; white-space: normal;
      }
      .violation-editor .time-selects select { min-width: 0; }
    }
    @media (max-width: 360px) {
      #shotPreview .tool-row .btn { flex: 1 1 100%; min-width: 0; width: 100%; }
      #shotPreview .plate-preview img { max-width: 160px; }
    }

    /* =========================================================
       Hardening（保守保護）
       ========================================================= */
    html, body { overflow-x: hidden; }
    .page, #shotPreview, .violation-editor {
      width: min(100%, var(--content-max)); margin-inline: auto;
    }
    .media-area, .violation-editor, #staticImageContainer, #shotPreview .editor-right {
      max-width: 100%; overflow: hidden;
    }
    img, video, canvas { max-width: 100%; height: auto; display: block; }
    #shotPreview .editor-grid { overflow-x: hidden; }

    .page-title {
      font-size: clamp(16px, 4vw, 24px);
    }
  </style>
</head>
<body>
  <div class="page-title-bar">
    <div class="page-title">
      <h1>違規檢舉小幫手</h1>
    </div>
    <!-- 顯示在畫面最右上角的主題切換開關 -->
    <div class="theme-toggle" role="group" aria-label="主題切換">
      <span class="label" id="themeLabel">深色</span>
      <input type="checkbox" id="themeSwitch" aria-labelledby="themeLabel" />
    </div>
  </div>

  <!-- 檔案選擇與狀態（含「顯示 Log」核取方塊） -->
  <div class="panel">
    <div class="controls">
      <input id="file" type="file" accept="video/*,.ts" />
      <span id="fileInfo" class="hint">請選擇影片（支援 .mp4 / .ts / .mov 等）</span>
    </div>
    <p class="status" id="status" role="status" aria-live="polite">狀態：初始化中…</p>
    <div class="controls">
      <label><input type="checkbox" id="toggleLog" /> 顯示 Log</label>
    </div>
  </div>

  <!-- 主面板：預覽 + 上下雙滑桿 + 按鈕 -->
  <div class="panel">
    <div class="col">
      <!-- 左側：預覽與上下雙滑桿 -->
      <div class="media-area">
        <div>
          <h3>輸出操作</h3>
          <div class="controls">
            <button id="btnClip" class="primary" disabled>剪輯並輸出</button>
            <button id="btnDownloadFull" disabled>下載完整轉檔</button>
            <button id="btnThumbnail" disabled>擷取縮圖</button>
          </div>
          <p id="out" class="hint"></p>
        </div>

        <video id="preview" controls playsinline></video>
        <div class="time" style="margin-top:.5rem;">
          目前：<span id="cur">00:00:00.00</span> / 片長：<span id="dur">00:00:00.00</span>
        </div>

        <div class="stacked-slider">
          <div class="rail" id="rail">
            <div class="track top"></div>
            <div class="track bottom"></div>
            <div class="selection" id="selection"></div>

            <!-- 上：開始滑桿（初始 0/100） -->
            <input id="startRange" type="range" min="0" max="100" step="0.01" value="0" />
            <!-- 下：結束滑桿（初始就在 100%） -->
            <input id="endRange"   type="range" min="0" max="100" step="0.01" value="100" />
          </div>

          <div class="controls" style="margin-top:.5rem;">
            <span class="chip time" id="startLabel">開始：00:00:00.00</span>
            <span class="chip time" id="endLabel">結束：00:00:00.00</span>
          </div>
        </div>
      </div>

      <!-- 右側：編輯車牌、日期、違規事項區域 -->
      <div>
        <h3 class="group-title">違規資訊</h3>
        <!-- Editor 掛載點（此節點會被 initViolationEditor() 插入內容） -->
        <section id="violation-editor-root"></section>
      </div>
    </div>
  </div>

  <!-- 大型截圖預覽面板 -->
  <div class="panel">
    <h3>截圖預覽</h3>
    <div class="shot-box">
      <div id="shotPreview" class="shot-preview">
        <span class="hint">尚未擷取縮圖</span>
      </div>
    </div>
  </div>

  <!-- Log（預設隱藏；勾選顯示） -->
  <div id="logPanel" class="panel log-panel">
    <h3>Log</h3>
    <div class="log" id="log">Log：</div>
  </div>

  <script type="module">
    /********** 基本 UI **********/
    const statusEl   = document.getElementById('status');
    const logEl      = document.getElementById('log');
    const logPanel   = document.getElementById('logPanel');
    const toggleLog  = document.getElementById('toggleLog');
    const fileInput  = document.getElementById('file');
    const fileInfo   = document.getElementById('fileInfo');
    const preview    = document.getElementById('preview');
    const curEl      = document.getElementById('cur');
    const durEl      = document.getElementById('dur');
    const rail       = document.getElementById('rail');
    const selectionEl= document.getElementById('selection');
    const startRange = document.getElementById('startRange');
    const endRange   = document.getElementById('endRange');
    const startLabel = document.getElementById('startLabel');
    const endLabel   = document.getElementById('endLabel');
    const btnClip         = document.getElementById('btnClip');
    const btnDownloadFull = document.getElementById('btnDownloadFull');
    const btnThumbnail    = document.getElementById('btnThumbnail');
    const shotPreviewBox  = document.getElementById('shotPreview');

    toggleLog.addEventListener('change', () => {
      logPanel.classList.toggle('show', toggleLog.checked);
    });

    /********** 主題切換（深色 / 明亮） **********/
    (function setupThemeToggle() {
      const html = document.documentElement;
      const sw = document.getElementById('themeSwitch');
      const lbl = document.getElementById('themeLabel');
      if (!sw || !lbl) return;

      // 根據 localStorage 或系統偏好初始化
      const LS_KEY = 'app-theme';
      const saved = localStorage.getItem(LS_KEY); // 'dark' | 'light' | null
      const sysPrefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;

      let theme = saved || (sysPrefersLight ? 'light' : 'dark');
      applyTheme(theme);

      // 切換事件
      sw.addEventListener('change', () => {
        theme = sw.checked ? 'light' : 'dark';
        applyTheme(theme, true);
      });

      // 套用主題並記錄
      function applyTheme(mode, persist = false) {
        if (mode === 'light') {
          html.setAttribute('data-theme', 'light');
          sw.checked = true;
          lbl.textContent = '明亮';
        } else {
          html.removeAttribute('data-theme');
          sw.checked = false;
          lbl.textContent = '深色';
        }
        if (persist) localStorage.setItem(LS_KEY, mode);
      }
    })();

    const log = (...msgs) => {
      const ts = new Date().toISOString();
      const s = msgs.map(m => { if (typeof m === 'string') return m; try { return JSON.stringify(m); } catch { return String(m); } }).join(' ');
      logEl.textContent += `\n[${ts}] ${s}`;
      logEl.scrollTop = logEl.scrollHeight;
      console.log(...msgs);
    };
    const errlog = (...msgs) => { log('ERROR:', ...msgs); console.error(...msgs); };
    const fmt = (t) => {
      if (!isFinite(t)) return '00:00:00.00';
      const h = Math.floor(t / 3600);
      const m = Math.floor((t % 3600) / 60);
      const s = t % 60;
      return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${s.toFixed(2).padStart(5,'0')}`;
    };

    if ('ResizeObserver' in window && rail) {
      const ro = new ResizeObserver(() => {
        // 只要 rail 寬度有變化（panel 展開 / grid 變更 / 視窗 resize 等），重畫選取色帶
        updateSelectionBar();
      });
      ro.observe(rail);
    }

    /** =========================
     * 違規紀錄編輯器（命名空間版）
     * ========================= */
    function initViolationEditor(root) {
      root.innerHTML = `
        <div class="violation-editor">
          <div class="toolbar" role="group" aria-label="違規資料輸入區">
            <div class="group">
              <label for="ve-plate1">車牌號碼：</label>
              <div class="plate-boxes">
                <input id="ve-plate1" type="text" inputmode="latin" maxlength="4" placeholder="ABCD" aria-label="車牌前段（最多 4 英數字）" />
                <span class="dash">—</span>
                <input id="ve-plate2" type="text" inputmode="latin" maxlength="4" placeholder="1234" aria-label="車牌後段（最多 4 英數字）" />
              </div>
            </div>
    
            <!-- 違規項目 -->
            <div class="group full">
              <label for="ve-violation">違規項目：</label>
              <div class="violation-row" style="display:flex; gap:8px; align-items:center; min-width:0; flex:1 1 auto;">
                <select id="city-select" aria-label="選擇縣市"></select>
                <select id="ve-violation" aria-label="選擇違規項目"></select>
              </div>
            </div>
            <div class="group">
              <label for="ve-date">違規日期：</label>
              <input id="ve-date" type="date" />
            </div>
            <div class="group">
              <label for="ve-hour">違規時間：</label>
              <div class="time-selects" aria-label="違規時間">
                <select id="ve-hour" aria-label="小時"></select>
                <select id="ve-minute" aria-label="分鐘"></select>
              </div>
            </div>
            <div class="group full">
              <label for="ve-road">路段：</label>
              <input id="ve-road" type="text" style="min-width: 240px; flex: 1 1 auto;"
                     value="違規地址" placeholder="請在此填寫違規地址" aria-label="請在此填寫違規地址" />
            </div>
          </div>

          <div class="preview" aria-live="polite">
            <textarea id="ve-output" spellcheck="false"></textarea>
            <div class="control-row">
              <label><input type="checkbox" id="ve-pause"> 暫停自動更新</label>
              <button class="btn" id="ve-copy" type="button" aria-label="複製到剪貼簿">複製到剪貼簿</button>
            </div>
          </div>
        </div>
      `;

      const $ = (sel) => root.querySelector(sel);
      function buildTimeOptions() {
        const hSel = $('#ve-hour'); const mSel = $('#ve-minute');
        hSel.innerHTML = ''; mSel.innerHTML = '';
        for (let h = 0; h <= 23; h++) {
          const opt = document.createElement('option'); opt.value = String(h).padStart(2, '0'); opt.textContent = opt.value; hSel.appendChild(opt);
        }
        for (let m = 0; m <= 59; m++) {
          const opt = document.createElement('option'); opt.value = String(m).padStart(2, '0'); opt.textContent = opt.value; mSel.appendChild(opt);
        }
      }
      function setDefaultDateTime() {
        const now = new Date();
        const yyyy = now.getFullYear();
        const mm = String(now.getMonth() + 1).padStart(2, '0');
        const dd = String(now.getDate()).padStart(2, '0');
        $('#ve-date').value = `${yyyy}-${mm}-${dd}`;
        const rounded = Math.round(now.getMinutes() / 10) * 10;
        $('#ve-hour').value = String(now.getHours()).padStart(2, '0');
        $('#ve-minute').value = String(rounded % 60).padStart(2, '0');
      }
      function sanitizePlate(el) {
        el.addEventListener('input', () => {
          const cleaned = el.value.replace(/[^0-9a-z]/gi, '').toUpperCase().slice(0, 4);
          if (cleaned !== el.value) el.value = cleaned;
          updateOutput();
        });
        el.addEventListener('change', updateOutput);
      }
      function formatDateToYMD(dateStr) {
        if (!dateStr) return '';
        const d = new Date(dateStr + 'T00:00:00'); if (isNaN(d.getTime())) return '';
        const y = d.getFullYear(); const m = String(d.getMonth() + 1).padStart(2, '0'); const day = String(d.getDate()).padStart(2, '0');
        return `${y}/${m}/${day}`;
      }
      function buildText() {
        const p1 = ($('#ve-plate1').value || '');
        const p2 = ($('#ve-plate2').value || '');
        const plate = (p1 || p2) ? `${p1}${p1 && p2 ? '-' : ''}${p2}` : '（車號未填）';
        const d = formatDateToYMD($('#ve-date').value);
        const hh = $('#ve-hour').value || '00';
        const min = $('#ve-minute').value || '00';
        const dt = d ? `${d} ${hh}:${min}` : '（日期/時間未填）';
        const road = ($('#ve-road').value || '').trim() || '請在此填寫違規地址';
        const vioSel = $('#ve-violation'); const vio = vioSel.value || '（尚未選擇違規項目）';
        return `${dt}，車號: ${plate} 於 "${road}"，${vio}。`;
      }

      function updateOutput() {
        if ($('#ve-pause').checked) return;
        $('#ve-output').value = buildText();
      }

      function bindEvents() {
        ['#ve-date','#ve-hour','#ve-minute','#ve-violation','#ve-road'].forEach(sel => {
          root.querySelector(sel).addEventListener('input', updateOutput);
          root.querySelector(sel).addEventListener('change', updateOutput);
        });
        $('#ve-pause').addEventListener('change', function () { if (!this.checked) updateOutput(); });
        $('#ve-copy').addEventListener('click', async () => {
          const text = $('#ve-output').value;
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text); toast('已複製到剪貼簿');
            } else {
              const ta = $('#ve-output'); ta.select(); document.execCommand('copy'); toast('已複製到剪貼簿'); ta.setSelectionRange(ta.value.length, ta.value.length);
            }
          } catch (e) { alert('複製失敗，請手動選取後按 Ctrl+C。'); }
        });
      }
      (function init() {
        buildTimeOptions();
        setDefaultDateTime();
        sanitizePlate($('#ve-plate1'));
        sanitizePlate($('#ve-plate2'));
        bindEvents();
        updateOutput();
      })();
    }
    const veMount = document.getElementById('violation-editor-root');
    if (veMount) initViolationEditor(veMount);
    
    // 在違規編輯器 DOM 建好之後，初始化下拉資料
    if (window.initViolationDropdowns) {
      window.initViolationDropdowns();
    }

    /********** FFmpeg 本地載入（classic worker + wasmBinary） **********/
    const BASE = new URL('.', import.meta.url);
    const CORE_JS   = new URL('./core/ffmpeg-core.js', BASE).href;
    const CORE_WASM = new URL('./core/ffmpeg-core.wasm', BASE).href;
    const WORKER_JS = new URL('./ffmpeg/worker.js', BASE).href;

    const fileToUint8Array = async (fileOrBlob) => new Uint8Array(await fileOrBlob.arrayBuffer());

    // 匯入你本地的 FFmpeg ESM 入口
    let FFmpegCtor;
    let ffmpeg;
    try {
      const mod = await import('./ffmpeg/index.js');
      FFmpegCtor = mod.FFmpeg || mod.default;
    } catch (e) {
      statusEl.textContent = '狀態：載入 FFmpeg 入口失敗 ❌';
      errlog('無法 import ./ffmpeg/index.js：', e?.message || e);
    }

    async function waitSWReady(ms = 5000) {
      try {
        return await Promise.race([
          navigator.serviceWorker.ready,
          new Promise((_, reject) => setTimeout(() => reject(new Error('Service Worker 啟動逾時')), ms))
        ]);
      } catch (e) {
        errlog('Service Worker 可能未就緒：', e?.message || e);
      }
    }

    const startFFmpeg = async () => {
      try {
        statusEl.textContent = '狀態：等待 Service Worker 就緒…';
        await waitSWReady(5000);
        log('crossOriginIsolated =', String(self.crossOriginIsolated));
        ffmpeg = new FFmpegCtor();
        if (ffmpeg?.on) {
          ffmpeg.on('log', ({ message }) => log('[ffmpeg]', message));
          ffmpeg.on('progress', (p) => log('[progress]', JSON.stringify(p)));
        }
        statusEl.textContent = '狀態：正在載入 FFmpeg…（首次載入較慢）';
        await ffmpeg.load({ coreURL: CORE_JS, wasmURL: CORE_WASM, workerURL: WORKER_JS });
        statusEl.textContent = `狀態：FFmpeg 載入完成 ✅`;
        log('FFmpeg 已就緒。');
        setActionsEnabled(false);
      } catch (err) {
        statusEl.textContent = `狀態：載入失敗 ❌ ${err?.message || err}`;
        errlog('初始化失敗：', err?.stack || err);
      }
    };

    await startFFmpeg();

    function toast(msg) {
      const div = document.createElement('div');
      Object.assign(div.style, {
        position: 'fixed', left: '50%', bottom: '24px', transform: 'translateX(-50%)',
        background: '#1d2129', color: '#fff', padding: '8px 12px', borderRadius: '6px',
        fontSize: '14px', zIndex: '9999', border: '1px solid var(--border)'
      });
      div.textContent = msg; document.body.appendChild(div); setTimeout(() => div.remove(), 1200);
    }

    /********** 檔案狀態（TS → 自動重封裝 MP4） **********/
    let selectedFileRaw = null;
    let playableBlob    = null;
    let playableName    = '';
    let autoMp4Blob     = null;
    let autoMp4Url      = '';
    let currentObjectURL = '';
    let FfmpegArgs = ['-i', 'inputfile', '-c', 'copy', '-tag:v', 'hvc1', '-bsf:a', 'aac_adtstoasc', '-movflags', '+faststart', 'automp4.mp4'];

    function revokeURL(url) { try { if (url) URL.revokeObjectURL(url); } catch {} }
    function setActionsEnabled(enabled) {
      btnClip.disabled = !enabled;
      btnDownloadFull.disabled = !enabled;
      btnThumbnail.disabled = !enabled;
    }
    function resetClipUI(dur = 0) {
      if (dur > 0) {
        startRange.min = 0; endRange.min = 0;
        startRange.max = dur; endRange.max = dur;
        startRange.value = 0; endRange.value = dur;
      } else {
        startRange.min = 0; endRange.min = 0;
        startRange.max = 100; endRange.max = 100;
        startRange.value = 0; endRange.value = 100;
      }
      startLabel.textContent = `開始：${fmt(0)}`;
      endLabel.textContent   = `結束：${fmt(dur || 0)}`;
      updateSelectionBar();
      requestAnimationFrame(() => {     // 佈局完成後再保險重畫
        updateSelectionBar();
      });
    }
    function triggerDownloadFromBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    // 小工具：用一次 exec('-i input.ts') 的 log 來判斷 video codec（不轉碼、很快）
    async function detectTsVideoCodec(ffmpeg, inName) {
      return new Promise(async (resolve) => {
        let videoCodec = null;
        const handler = ({ message }) => {
          // 典型行例如： "Video: hevc (Main) ..." / "Video: h264 (High) ..."
          const m = typeof message === 'string' && message.match(/Video:\s*([a-zA-Z0-9_]+)/);
          if (m) videoCodec = m[1].toLowerCase();
        };
        ffmpeg.on && ffmpeg.on('log', handler);
        try {
          // 輕探測。-hide_banner 只為少點雜訊；失敗也沒關係（我們只要 log）
          await ffmpeg.exec(['-hide_banner', '-i', inName]).catch(() => {});
        } finally {
          // 簡單移除監聽（若你的 FFmpeg.on 無 off，可忽略）
          // ffmpeg.off && ffmpeg.off('log', handler);
          resolve(videoCodec); // 可能為 null（解析不到時）
        }
      });
    }

    // ✅ 快照 URL 追蹤與釋放
    let lastSnapshotURL = null;
    fileInput.onchange = async () => {
      const file = fileInput.files?.[0];
      // 清理快照 URL
      if (lastSnapshotURL) { URL.revokeObjectURL(lastSnapshotURL); lastSnapshotURL = null; }

      revokeURL(currentObjectURL); currentObjectURL = '';
      if (!(EditorLite.isReady && EditorLite.isReady())) {
        shotPreviewBox.innerHTML = '<span class="hint">尚未擷取縮圖</span>';
      }

      if (!file) {
        selectedFileRaw = null; playableBlob = null; playableName = '';
        autoMp4Blob = null; autoMp4Url = '';
        setActionsEnabled(false);
        preview.removeAttribute('src'); preview.load();
        fileInfo.textContent = '請選擇影片（支援 .mp4 / .ts / .mov 等）';
        resetClipUI(0);
        return;
      }

      selectedFileRaw = file;
      const lower = (file.name || '').toLowerCase();
      const isTS = lower.endsWith('.ts');

      try {
        if (isTS) {
          const inName = 'input.ts';
          const outName = 'automp4.mp4';
          await ffmpeg.writeFile(inName, await fileToUint8Array(file));
          // 先探測 TS 視訊編碼
          const vCodec = await detectTsVideoCodec(ffmpeg, inName);
          const tagMap = {
            h264: 'avc1',
            avc:  'avc1',
            hevc: 'hvc1',
            h265: 'hvc1'
          };
          const tag = tagMap[vCodec];
          if (!tag) {
            fileInfo.textContent = `不支援的 TS 格式：${vCodec || '未知'}`;
            return;
          }
          FfmpegArgs[1] = inName;
          FfmpegArgs[5] = tag;  // 套用正確的 tag
          FfmpegArgs[FfmpegArgs.length - 1] = outName;
          log('偵測到 TS，執行快速轉換容器為 MP4…', FfmpegArgs);
          await ffmpeg.exec(FfmpegArgs);
          const data = await ffmpeg.readFile(outName);
          autoMp4Blob = new Blob([data.buffer], { type: 'video/mp4' });
          playableBlob = autoMp4Blob;
          playableName = 'input.mp4';
          autoMp4Url   = URL.createObjectURL(autoMp4Blob);
          currentObjectURL = autoMp4Url;
          fileInfo.textContent = `已選擇：${file.name}(${(file.size/1024/1024).toFixed(2)} MB) | 自動重封裝為 MP4`;
          // 清理 FFmpeg 虛擬檔案
          try { await ffmpeg.deleteFile?.(inName); } catch {}
          try { await ffmpeg.deleteFile?.(outName); } catch {}
        } else {
          // 原本邏輯：非 TS 直接預覽
          playableBlob = file;
          playableName = inferInputName(file.name);
          autoMp4Blob  = null; autoMp4Url = '';
          currentObjectURL = URL.createObjectURL(file);
          fileInfo.textContent = `已選擇：${file.name}(${(file.size/1024/1024).toFixed(2)} MB)`;
        }
        preview.src = currentObjectURL;
        preview.load();
        setActionsEnabled(true);
      } catch (e) {
        errlog('載入/轉檔失敗：', e?.message || e);
        alert('載入或自動轉檔失敗：' + (e?.message || e));
        setActionsEnabled(false);
      }
    };

    /********** 預覽時間顯示 **********/
    preview.addEventListener('loadedmetadata', () => {
      const dur = preview.duration;
      durEl.textContent = fmt(dur);
      curEl.textContent = fmt(preview.currentTime || 0);
      resetClipUI(isFinite(dur) ? dur : 0);
    });
    preview.addEventListener('timeupdate', () => {
      curEl.textContent = fmt(preview.currentTime);
    });

    /********** 上下雙滑桿：聯動 + 連動預覽 + 著色選取範圍 **********/
    function updateSelectionBar() {
      const hasDur = isFinite(preview.duration) && preview.duration > 0;
      const rangeMax = hasDur ? preview.duration : parseFloat(startRange.max) || 100;

      let startVal = parseFloat(startRange.value);
      let endVal   = parseFloat(endRange.value);
      if (startVal > endVal) [startVal, endVal] = [endVal, startVal];

      const rect = rail.getBoundingClientRect();
      const innerW = rect.width;

      const startPct = Math.max(0, Math.min(1, startVal / rangeMax));
      const endPct   = Math.max(0, Math.min(1, endVal   / rangeMax));
      const leftPx   = innerW * startPct;
      const widthPx  = innerW * (endPct - startPct);

      selectionEl.style.left  = `${leftPx}px`;
      selectionEl.style.width = `${widthPx}px`;
    }

    const clampAndPreview = (who) => {
      const hasDur = isFinite(preview.duration) && preview.duration > 0;
      let s = parseFloat(startRange.value);
      let e = parseFloat(endRange.value);
      if (who === 'start' && s > e) { endRange.value = s; e = s; }
      if (who === 'end'   && e < s) { startRange.value = e; s = e; }

      startLabel.textContent = `開始：${fmt(hasDur ? s : 0)}`;
      endLabel.textContent   = `結束：${fmt(hasDur ? e : 0)}`;

      if (hasDur) {
        if (who === 'start' && isFinite(s)) preview.currentTime = s;
        if (who === 'end'   && isFinite(e)) preview.currentTime = e;
      }
      updateSelectionBar();
    };
    startRange.addEventListener('input', () => clampAndPreview('start'));
    endRange.addEventListener('input',   () => clampAndPreview('end'));
    window.addEventListener('resize', updateSelectionBar);

    /********** 輔助：推斷輸入檔名（容器名）**********/
    function inferInputName(name) {
      const lower = (name || '').toLowerCase();
      if (lower.endsWith('.mp4')) return 'input.mp4';
      if (lower.endsWith('.ts'))  return 'input.ts';
      if (lower.endsWith('.mov')) return 'input.mov';
      if (lower.endsWith('.mkv')) return 'input.mkv';
      if (lower.endsWith('.mp3')) return 'input.mp3';
      return 'input.mp4';
    }

    /********** 功能 1：剪輯並輸出（不重編碼，-c copy）→ 直接下載 **********/
    btnClip.onclick = async () => {
      try {
        if (!playableBlob) { alert('請先選擇檔案'); return; }

        const s = parseFloat(startRange.value);
        const e = parseFloat(endRange.value);
        if (!isFinite(s) || !isFinite(e)) { alert('請設定開始與結束時間'); return; }
        if (e <= s) { alert('結束時間必須大於開始時間'); return; }

        const inName = playableName || 'input.mp4';
        const outName = 'clip.mp4';

        log('開始快速剪輯（無轉碼）…', { start: s, end: e, inName, outName });
        await ffmpeg.writeFile(inName, await fileToUint8Array(playableBlob));

        const ss = s.toFixed(2);
        const to = e.toFixed(2);
        // 精準（較慢）：-ss 在 -i 之後
        await ffmpeg.exec(['-i', inName, '-ss', ss, '-to', to, '-c', 'copy', outName]);

        const data = await ffmpeg.readFile(outName);
        const blob = new Blob([data.buffer], { type: 'video/mp4' });
        triggerDownloadFromBlob(blob, outName);
        toast(`已下載剪輯檔 (${ss}s → ${to}s)`);
        log('剪輯完成並已觸發下載 ✅');
      } catch (e) {
        errlog('快速剪輯失敗：', e?.message || e);
        alert('剪輯失敗：' + (e?.message || e));
      } finally {
        // 清理暫存檔案
        try { await ffmpeg.deleteFile?.('clip.mp4'); } catch {}
        try {
          const inName = playableName || 'input.mp4';
          await ffmpeg.deleteFile?.(inName);
        } catch {}
      }
    };

    /********** 功能 2：下載完整轉檔 **********/
    btnDownloadFull.onclick = async () => {
      try {
        if (!selectedFileRaw) { alert("請先選擇檔案"); return; }

        const lower = (selectedFileRaw.name || '').toLowerCase();
        const isTS = lower.endsWith('.ts');

        if (isTS) {
          if (autoMp4Blob) {
            triggerDownloadFromBlob(autoMp4Blob, 'converted.mp4');
            toast('已下載自動轉檔 MP4');
            log('TS 已自動轉檔完成，觸發下載 converted.mp4 ✅');
            return;
          }
          const inName = 'input.ts';
          const outName = 'automp4.mp4';
          await ffmpeg.writeFile(inName, await fileToUint8Array(selectedFileRaw));
          FfmpegArgs[1] = inName;
          FfmpegArgs[FfmpegArgs.length - 1] = outName;
          await ffmpeg.exec(FfmpegArgs);
          const data = await ffmpeg.readFile(outName);
          const blob = new Blob([data.buffer], { type: 'video/mp4' });
          triggerDownloadFromBlob(blob, 'converted.mp4');
          toast('已下載自動轉檔 MP4');
          log('TS 重新自動轉檔後觸發下載 ✅');
          try { await ffmpeg.deleteFile?.(inName); } catch {}
          try { await ffmpeg.deleteFile?.(outName); } catch {}
        } else {
          const inName = inferInputName(selectedFileRaw.name);
          await ffmpeg.writeFile(inName, await fileToUint8Array(selectedFileRaw));
          await ffmpeg.exec(['-i', inName, '-movflags', 'faststart', 'output.mp4']);
          const data = await ffmpeg.readFile('output.mp4');
          const blob = new Blob([data.buffer], { type: 'video/mp4' });
          triggerDownloadFromBlob(blob, 'output.mp4');
          toast('已下載自動轉檔 MP4');
          log('完整轉檔完成並已觸發下載 ✅');
          try { await ffmpeg.deleteFile?.(inName); } catch {}
          try { await ffmpeg.deleteFile?.('output.mp4'); } catch {}
        }
      } catch (e) {
        errlog('完整轉檔失敗：', e?.message || e);
        alert('完整轉檔失敗：' + (e?.message || e));
      }
    };

    /********** 功能 3：擷取縮圖 **********/
    btnThumbnail.onclick = async () => {
      try {
        if (!(EditorLite.isReady && EditorLite.isReady())) {
          shotPreviewBox.innerHTML = '<span class="hint">擷取中…</span>';
        }
    
        if (!preview || !preview.videoWidth) {
          alert("影片尚未載入或沒有可用影格");
          shotPreviewBox.innerHTML = '<span class="hint">尚未擷取縮圖</span>';
          return;
        }
        await new Promise((resolve) => {
          if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
            let done = false;
            preview.requestVideoFrameCallback(() => { if (!done) { done = true; resolve(); } });
            if (preview.paused) { done = true; resolve(); }
          } else {
            requestAnimationFrame(() => resolve());
          }
        });
        const w = preview.videoWidth;
        const h = preview.videoHeight;
        const canvas = document.createElement('canvas');
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d');
        const t = preview.currentTime;
        const ss = isFinite(t) ? t.toFixed(2) : '0';
    
        if ('createImageBitmap' in window) {
          try {
            const bmp = await createImageBitmap(preview);
            ctx.drawImage(bmp, 0, 0, w, h);
            bmp.close?.();
          } catch {
            ctx.drawImage(preview, 0, 0, w, h);
          }
        } else {
          ctx.drawImage(preview, 0, 0, w, h);
        }
    
        const blob = await new Promise((resolve, reject) =>
          canvas.toBlob(b => b ? resolve(b) : reject(new Error('toBlob 失敗')), 'image/png', 0.92)
        );
        const url = URL.createObjectURL(blob);

        // 釋放上一張快照 URL
        if (lastSnapshotURL && lastSnapshotURL !== url) {
          URL.revokeObjectURL(lastSnapshotURL);
        }
        lastSnapshotURL = url;

        // 顯示到你保留的 #shotPreview（不新增任何外部節點/屬性）
        if (!(EditorLite.isReady && EditorLite.isReady())) {
          shotPreviewBox.innerHTML = '';
          const img = document.createElement('img');
          img.src = url;
          img.alt = `縮圖（${ss}s）`;
          img.loading = 'lazy';
          img.decoding = 'async';
          shotPreviewBox.appendChild(img);
        }
        toast(`已擷取縮圖（${ss}s）`);
        log('Canvas 擷取完成 ✅', { currentTime: ss, width: w, height: h });

        // 初始化或僅換底圖（避免重建 UI 造成狀態不同步）
        if (EditorLite.isReady && EditorLite.isReady()) {
          // 已經初始化過僅換底圖
          EditorLite.loadSnapshot(url);
        } else {
          // 第一次初始化
          EditorLite.init(shotPreviewBox, { videoEl: preview, snapshotURL: url });
        }
      } catch (e) {
        shotPreviewBox.innerHTML = '<span class="hint">尚未擷取縮圖</span>';
        errlog('擷取縮圖失敗：', e?.message || e);
        alert('擷取縮圖失敗：' + (e?.message || e));
      }
    };

    /*** === EditorLite 模組（最小整合到 #shotPreview）=== ***/
    (function ensureEditorLiteStyles() {
      const id = 'editorlite-styles';
      const el = document.getElementById(id);
      if (el) { return; }
      const style = document.createElement('style');
      style.id = id;
      style.textContent = `
        #shotPreview .editor-grid {
          display: grid;
          grid-template-columns: minmax(0, 1fr) 340px;
          grid-auto-rows: auto;
          gap: 14px;
          align-items: start;
        }
        #shotPreview .editor-left { display: flex; flex-direction: column; gap: 10px; }
        #shotPreview .editor-header { display: flex; align-items: center; gap: 12px; }
        #shotPreview .editor-header h3 { margin: 0; font-weight: 600; color: var(--fg); }
        #shotPreview .tool-row { display: flex; gap: 8px; flex-wrap: wrap; }
        #shotPreview .tool-row .btn {
          padding: 8px 12px; border: 1px solid var(--border);
          background: var(--panel); color: var(--fg);
          border-radius: 6px; cursor: pointer; font-weight: 600;
        }
        #shotPreview .tool-row .btn:hover { background: var(--panel); }
        #shotPreview .editor-stage {
          position: relative;
          background: var(--panel);
          border: 1px solid var(--border);
          border-radius: 8px;
          padding: 10px;
          min-height: clamp(120px, 40vw, 360px);
        }
        @media (orientation: portrait) {
          #shotPreview .editor-stage {
            min-height: 0;
            padding-bottom: 8px;
          }
        }
        #shotPreview #staticImageContainer { position: relative; }
        #shotPreview #staticImage { max-width: 100%; height: auto; display: block; }
        #shotPreview #drawingOverlay {
          position: absolute; left: 0; top: 0;
          display: none; pointer-events: auto;
        }
        #shotPreview #selectionBox {
          position: absolute; border: 2px solid #e53935;
          background: rgba(229,57,53,.12); display: none;
          border-radius: 4px;
        }
        #shotPreview .plate-preview {
          display: none; gap: 10px; align-items: center; padding: 8px;
          border: 1px dashed var(--border); border-radius: 6px; background: var(--panel);
        }
        #shotPreview .plate-preview img { border: 2px solid #e53935; max-width: 150px; height: auto; }
        #shotPreview .plate-preview .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        #shotPreview .plate-preview label { color: var(--fg); }
        #shotPreview .editor-right {
          border: 1px solid var(--border); border-radius: 8px; padding: 10px; background: var(--panel);
          display: flex; flex-direction: column; gap: 8px;
          max-height: 100%;
        }
        #shotPreview .editor-right h3 { margin: 0; font-weight: 600; color: var(--fg); }
        #shotPreview #generatedImagesArea {
          display: flex; flex-direction: column; gap: 12px;
          overflow: auto; flex: 1;
        }
        #shotPreview .generated-image-card {
          border: 1px solid var(--border); border-radius: 8px; padding: 8px;
          background: var(--panel);
        }
        #shotPreview .generated-image-card .inner {
          border: 1px solid var(--border); border-radius: 6px; padding: 6px; background: var(--panel);
        }
        #shotPreview .generated-image-card .header {
          display: flex; gap: 8px; align-items: center; justify-content: space-between; margin-bottom: 6px; color: var(--fg);
        }
        #shotPreview .generated-image-card .btn-row { display: flex; gap: 8px; }
        #shotPreview .generated-image-card img { max-width: 100%; height: auto; cursor: pointer; border-radius: 4px; }
        #shotPreview .generated-image-card .download-btn,
        #shotPreview .generated-image-card .remove-btn {
          padding: 6px 10px; border: 1px solid var(--border); background: var(--panel); color: var(--fg); border-radius: 6px;
          white-space: nowrap;
        }
        #shotPreview .generated-image-card .download-btn:hover,
        #shotPreview .generated-image-card .remove-btn:hover { background: var(--panel); }
  
        @media (max-width: 840px) {
          #shotPreview .editor-grid { grid-template-columns: 1fr; }
        }
      `;
      document.head.appendChild(style);
    })();

    // ================= EditorLite 主體 =================
    const EditorLite = (() => {
      let initialized = false;
      let container;      // #shotPreview
      let videoEl;        // <video id="preview">
      let snapshotURL = '';
    
      let staticImageContainer, staticImage, selectionBox, drawingOverlay;
      let platePreviewArea, plateImg, platePositionSelect, plateScaleInput;
    
      let generatedImagesArea;
      const generatedItems = []; // {id, url, ts}
    
      let finalCanvas = document.createElement('canvas');
      let startX, startY, currentX, currentY;
      let isDrawing = false;
      let finalCropCoords = {};
      const dragThreshold = 5;
      let isDrawingMode = false;
      let drawnShapes = [];
      let plateImageInMemory = null;
      let currentShape = null;

      function undoLastShape() {
        if (drawnShapes.length > 0) {
          drawnShapes.pop();
          drawOverlayContent();
        }
      }
      let keybound = false;
    
      // 紅框選項
      let drawingModeBtn, drawingShapeSelect, lineThicknessInput, rotationCheckbox;
    
      // ========= 公開 API：初始化 =========
      function init(host, { videoEl: v, snapshotURL: url } = {}) {
        container = host;
        videoEl = v;
        snapshotURL = url || '';
    
        // 清空容器（外層不動）
        container.innerHTML = '';

        const grid = document.createElement('div');
        grid.className = 'editor-grid';

        const left = document.createElement('section');
        left.className = 'editor-left';

        const header = document.createElement('div');
        header.className = 'editor-header';
        const h3 = document.createElement('h3'); h3.textContent = ''; // 截圖預覽
        const toolRow = document.createElement('div'); toolRow.className = 'tool-row';

        const btnCrop = document.createElement('button'); btnCrop.textContent = '重新擷取車牌'; btnCrop.className = 'btn';
        drawingModeBtn = document.createElement('button'); drawingModeBtn.textContent = '開啟紅框編輯'; drawingModeBtn.className = 'btn';
        const btnUndo = document.createElement('button'); btnUndo.textContent = '撤銷紅框 (Ctrl+Z)'; btnUndo.className = 'btn';
        const btnGenerate = document.createElement('button'); btnGenerate.textContent = '產生最終截圖'; btnGenerate.className = 'btn';

        toolRow.append(btnCrop, drawingModeBtn, btnUndo, btnGenerate);
        header.append(h3, toolRow);
        left.appendChild(header);

        // 車牌預覽列
        platePreviewArea = document.createElement('div');
        platePreviewArea.className = 'plate-preview';
        const plateLabel = document.createElement('span'); plateLabel.textContent = '車牌預覽：'; plateLabel.style.color = 'var(--fg)';
        plateImg = document.createElement('img'); plateImg.alt = '車牌預覽圖'; plateImg.style.display = 'none';

        const posGroup = document.createElement('div'); posGroup.className = 'row';
        const posLabel = document.createElement('label'); posLabel.textContent = '位置';
        platePositionSelect = document.createElement('select');
        ['bottomRight','topRight','bottomLeft','topLeft'].forEach(v => {
          const opt = document.createElement('option'); opt.value = v;
          opt.textContent = ({bottomRight:'右下角', topRight:'右上角', bottomLeft:'左下角', topLeft:'左上角'})[v];
          platePositionSelect.appendChild(opt);
        });

        const scaleGroup = document.createElement('div'); scaleGroup.className = 'row';
        const scaleLabel = document.createElement('label'); scaleLabel.textContent = '縮放(%)';
        plateScaleInput = document.createElement('input'); plateScaleInput.type = 'range'; plateScaleInput.min = '10'; plateScaleInput.max = '50'; plateScaleInput.value = '30';
        const scaleValue = document.createElement('span'); scaleValue.id = 'scaleValue'; scaleValue.textContent = '30%';

        plateScaleInput.addEventListener('input', () => { scaleValue.textContent = `${plateScaleInput.value}%`; drawOverlayContent(); });
        platePositionSelect.addEventListener('change', drawOverlayContent);

        posGroup.append(posLabel, platePositionSelect);
        scaleGroup.append(scaleLabel, plateScaleInput, scaleValue);
        platePreviewArea.append(plateLabel, plateImg, posGroup, scaleGroup);
        left.appendChild(platePreviewArea);

        // 主畫布
        const stage = document.createElement('div');
        stage.className = 'editor-stage';

        staticImageContainer = document.createElement('div');
        staticImageContainer.id = 'staticImageContainer';
        staticImageContainer.style.cursor = 'crosshair';
        staticImageContainer.style.touchAction = 'none';

        staticImage = document.createElement('img');
        staticImage.id = 'staticImage';
        staticImage.alt = '靜態截圖預覽';
        staticImage.style.display = 'none';

        selectionBox = document.createElement('div'); selectionBox.id = 'selectionBox';
        drawingOverlay = document.createElement('canvas'); drawingOverlay.id = 'drawingOverlay';

        staticImageContainer.append(staticImage, selectionBox, drawingOverlay);
        stage.appendChild(staticImageContainer);
        left.appendChild(stage);

        // ---- 右側：列表（固定高度 + 自己捲軸） ----
        const right = document.createElement('aside');
        right.className = 'editor-right';
        
        // 標題 + 全部下載按鈕（保留原本標題）
        const headerBar = document.createElement('div');
        headerBar.style.display = 'flex';
        headerBar.style.alignItems = 'center';
        headerBar.style.justifyContent = 'space-between';
        headerBar.style.gap = '8px';
        
        const rh3 = document.createElement('h3');
        rh3.textContent = '截圖列表';

        const clearAllBtn = document.createElement('button');
        clearAllBtn.textContent = '全部清除';
        clearAllBtn.className = 'remove-btn';
        clearAllBtn.style.whiteSpace = 'nowrap';
        
        // 綁定清除全部事件（下方會定義 clearAllGenerated）
        clearAllBtn.onclick = clearAllGenerated;

        const downloadAllBtn = document.createElement('button');
        downloadAllBtn.textContent = '全部下載';
        downloadAllBtn.className = 'download-btn';
        downloadAllBtn.style.whiteSpace = 'nowrap';
        
        // 綁定下載全部事件
        downloadAllBtn.onclick = DownloadIndividually;
        const btnGroup = document.createElement('div');
        btnGroup.style.display = 'flex';
        btnGroup.style.gap = '8px';
        btnGroup.append(clearAllBtn, downloadAllBtn);
        
        headerBar.append(rh3, btnGroup)
        
        // 既有的列表容器
        generatedImagesArea = document.createElement('div');
        generatedImagesArea.id = 'generatedImagesArea';
        
        // 裝配
        right.append(headerBar, generatedImagesArea);

        // 組裝
        grid.append(left, right);
        container.appendChild(grid);

        // 綁定事件
        btnCrop.onclick = startLicensePlateCrop;
        drawingModeBtn.onclick = toggleDrawingMode;
        btnUndo.onclick = undoLastShape;
        btnGenerate.onclick = generateReportImage;

        // 快捷鍵：撤銷
        if (!keybound) {
          keybound = true;
          window.addEventListener('keydown', (e) => {
            const isZ = (e.key === 'z' || e.key === 'Z');
            const withCmd = e.metaKey || e.ctrlKey;
            if (withCmd && isZ) { e.preventDefault(); undoLastShape(); }
          });
        }

        // 有 snapshotURL：預載底圖＋建立 overlay
        if (snapshotURL) { staticImage.src = snapshotURL; staticImage.style.display = 'block'; setupDrawingOverlay(); }

        // 重新渲染既有生成列表（持久化）
        rebuildGeneratedList();
        // ===== 新增：還原車牌預覽列 =====
        restorePlatePreviewIfAny();
        // ✅ 保險：同步右欄高度貼齊左欄
        syncRightHeightWithLeft();
        // ✅ 新增：小螢幕下取消右欄鎖高（以便列表完整顯示）
        disableRightPaneHeightOnMobile();
        initialized = true;
      }

      // 一鍵清空「已生成的截圖列表」
      function clearAllGenerated() {
        if (!generatedItems || generatedItems.length === 0) {
          alert('目前沒有可清除的截圖');
          return;
        }
      
        // 確認提示（避免誤觸）
        const ok = confirm('確定要刪除所有截圖嗎？此動作無法復原。');
        if (!ok) return;
      
        // 清空記憶體陣列
        generatedItems.length = 0;
      
        // 清空右側列表 DOM
        if (generatedImagesArea) {
          generatedImagesArea.innerHTML = '';
        }
      }

      // 逐檔觸發下載（瀏覽器可能提示多檔下載）
      function DownloadIndividually() {
        if (!generatedItems || generatedItems.length === 0) {
          alert('目前沒有可下載的截圖');
          return;
        }
        // 依照加入順序逐張下載
        generatedItems.forEach((item, idx) => {
          // 檔名：report_YYYYMMDDHHMMSS_xxx.jpg
          const ts = new Date(item.ts || Date.now()).toISOString().slice(0,19).replace(/[-:T]/g,'');
          const fileName = `report_${ts}_${idx + 1}.jpg`;
          const a = document.createElement('a');
          a.download = fileName;
          a.href = item.url;        // 支援 dataURL / blob URL
          document.body.appendChild(a);
          a.click();
          a.remove();
        });
      }

      function syncRightHeightWithLeft() {
        const leftStage = container.querySelector('.editor-left');   // 左欄（含標題、工具列、主畫布）
        const rightPane = container.querySelector('.editor-right');  // 右欄（列表）
        if (!leftStage || !rightPane) return;
        // 設為左欄實際高度（含 padding/border）
        rightPane.style.height = `${leftStage.offsetHeight}px`;

        // 追蹤變化（左欄變動時自動同步）
        if ('ResizeObserver' in window) {
          const ro = new ResizeObserver(() => {
            rightPane.style.height = `${leftStage.offsetHeight}px`;
          });
          ro.observe(leftStage);
        } else {
          // Fallback：視窗縮放時同步
          window.addEventListener('resize', () => {
            rightPane.style.height = `${leftStage.offsetHeight}px`;
          });
        }
      }

      // （新增）手機上取消右欄高度鎖定
      function disableRightPaneHeightOnMobile() {
        const mq = window.matchMedia('(max-width: 840px)');
        const rightPane = container.querySelector('.editor-right');
        const apply = () => {
          if (!rightPane) return;
          if (mq.matches) {
            // 手機：取消鎖高，讓右欄能完整顯示
            rightPane.style.height = 'auto';
          } else {
            // 非手機：維持既有的同步高度（left/right 對齊）
            // 這行可留空，因為 syncRightHeightWithLeft 會處理
          }
        };
      
        apply();
        // MediaQuery 變化時同步
        if (mq.addEventListener) {
          mq.addEventListener('change', apply);
        } else {
          // 老瀏覽器相容
          mq.addListener && mq.addListener(apply);
        }
      }

      // ===== 實作：擷取車牌 → 顯示預覽列 =====
      function startLicensePlateCrop() {
        if (plateImageInMemory) {
          clearPlateCrop();
          return;
        }
        if (!videoEl || !videoEl.src || videoEl.videoWidth === 0) {
          alert('請先在主頁載入並預覽影片！'); return;
        }
        videoEl.pause();
        const c = document.createElement('canvas');
        c.width = videoEl.videoWidth; c.height = videoEl.videoHeight;
        const ctx = c.getContext('2d'); ctx.drawImage(videoEl, 0, 0, c.width, c.height);
        staticImage.src = c.toDataURL('image/jpeg');
        staticImage.style.display = 'block';
        selectionBox.style.display = 'none';
        setupDrawingOverlay();
        if (isDrawingMode) toggleDrawingMode();
      }

      // ===== Overlay：尺寸與事件綁定 =====
      function setupDrawingOverlay() {
        if (staticImage.style.display === 'none') return;
        const rect = staticImage.getBoundingClientRect();
        drawingOverlay.width = rect.width;
        drawingOverlay.height = rect.height;
        const baseRect = staticImageContainer.getBoundingClientRect();
        drawingOverlay.style.left = `${rect.left - baseRect.left}px`;
        drawingOverlay.style.top  = `${rect.top  - baseRect.top}px`;
        drawingOverlay.style.display = 'block';
        drawingOverlay.addEventListener('pointerdown', startUserDrawing);
        drawingOverlay.addEventListener('pointermove', drawUserMoving);
        drawingOverlay.addEventListener('pointerup', stopUserDrawing);
        drawingOverlay.addEventListener('pointercancel', stopUserDrawing);

        staticImageContainer.addEventListener('pointerdown', onSelectStart, { passive: false });
        staticImageContainer.addEventListener('pointermove', onSelectMove, { passive: false });
        staticImageContainer.addEventListener('pointerup',   onSelectEnd,  { passive: false });
        staticImageContainer.addEventListener('pointercancel', onSelectEnd, { passive: false });

        drawOverlayContent();

        // 追蹤尺寸變化
        if ('ResizeObserver' in window) {
          const ro = new ResizeObserver(() => {
            const r = staticImage.getBoundingClientRect();
            drawingOverlay.width = r.width;
            drawingOverlay.height = r.height;
            const b = staticImageContainer.getBoundingClientRect();
            drawingOverlay.style.left = `${r.left - b.left}px`;
            drawingOverlay.style.top  = `${r.top  - b.top}px`;
            drawOverlayContent();
          });
          ro.observe(staticImageContainer);
        }
      }
    
      // ===== 框選車牌（選擇矩形） =====
      function onSelectStart(e) {
        if (!isPrimaryPointer(e) || isDrawingMode) return;
        e.preventDefault(); e.stopPropagation();
        isDrawing = true;
        const rect = staticImage.getBoundingClientRect();
        startX = Math.round(e.clientX - rect.left);
        startY = Math.round(e.clientY - rect.top);
        selectionBox.style.display = 'block';
        selectionBox.style.left = `${startX}px`;
        selectionBox.style.top  = `${startY}px`;
        selectionBox.style.width = '0px';
        selectionBox.style.height= '0px';
        staticImageContainer.setPointerCapture?.(e.pointerId);
      }
      function onSelectMove(e) {
        if (!isDrawing || isDrawingMode) return;
        e.preventDefault(); e.stopPropagation();
        const rect = staticImage.getBoundingClientRect();
        currentX = Math.round(e.clientX - rect.left);
        currentY = Math.round(e.clientY - rect.top);
        const width = currentX - startX;
        const height= currentY - startY;
        selectionBox.style.left = `${width > 0 ? startX : currentX}px`;
        selectionBox.style.top  = `${height> 0 ? startY : currentY}px`;
        selectionBox.style.width= `${Math.abs(width)}px`;
        selectionBox.style.height=`${Math.abs(height)}px`;
      }
      function onSelectEnd(e) {
        if (!isDrawing || isDrawingMode) return;
        isDrawing = false;
        staticImageContainer.releasePointerCapture?.(e.pointerId);
        selectionBox.style.display = 'none';

        const dx = Math.abs(currentX - startX);
        const dy = Math.abs(currentY - startY);
        if (dx < dragThreshold && dy < dragThreshold) return;

        const displayW = staticImage.clientWidth;
        const displayH = staticImage.clientHeight;
        const actualW  = videoEl.videoWidth;
        const actualH  = videoEl.videoHeight;
        const scaleX = actualW / displayW;
        const scaleY = actualH / displayH;
        const x1 = Math.min(startX, currentX), y1 = Math.min(startY, currentY);
        const x2 = Math.max(startX, currentX), y2 = Math.max(startY, currentY);

        finalCropCoords = { x1: Math.round(x1*scaleX), y1: Math.round(y1*scaleY), x2: Math.round(x2*scaleX), y2: Math.round(y2*scaleY) };
        confirmCropArea();
      }

      function confirmCropArea() {
        const cropW = finalCropCoords.x2 - finalCropCoords.x1;
        const cropH = finalCropCoords.y2 - finalCropCoords.y1;
        if (cropW <= 0 || cropH <= 0) return;

        const c = document.createElement('canvas'); c.width = cropW; c.height = cropH;
        const ctx = c.getContext('2d');
        try {
          ctx.drawImage(videoEl, finalCropCoords.x1, finalCropCoords.y1, cropW, cropH, 0, 0, cropW, cropH);
          plateImageInMemory = new Image();
          plateImageInMemory.src = c.toDataURL('image/jpeg');

          plateImg.src = plateImageInMemory.src;
          plateImg.style.display = 'block';
          // 顯示車牌預覽列
          const plateBar = container.querySelector('.plate-preview');
          if (plateBar && plateBar.style) plateBar.style.display = 'flex';

          // ✅ onload 一次設定
          plateImageInMemory.onload = () => {
            drawOverlayContent();
            restorePlatePreviewIfAny(); // ✅ 保險：裁切完成後立即顯示車牌列
          };
        } catch (e) {
          console.error('裁切失敗：', e);
        }
      }

      function restorePlatePreviewIfAny() {
        const plateBar = container.querySelector('.plate-preview');
        if (!plateBar) return;
        if (plateImageInMemory) {
          plateImg.src = plateImageInMemory.src;
          plateImg.style.display = 'block';
          plateBar.style.display = 'flex';
          drawOverlayContent?.();
        } else {
          plateImg.style.display = 'none';
          plateBar.style.display = 'none';
        }
      }

      // ✅ 清除「已擷取車牌」的暫存影像與相關 UI
      function clearPlateCrop() {
        // 1) 清掉記憶體中的暫存車牌影像
        plateImageInMemory = null;
        // 2) 清掉裁切座標（可選）
        finalCropCoords = {};
        // 3) 隱藏車牌預覽列與預覽圖
        if (plateImg) {
          plateImg.removeAttribute('src');
          plateImg.style.display = 'none';
        }
        const plateBar = container.querySelector('.plate-preview');
        if (plateBar) {
          plateBar.style.display = 'none';
        }
        // 4) 重新繪製 overlay（不再疊車牌）
        drawOverlayContent?.();
      }

      // ===== Overlay 重繪：紅框、車牌貼上 =====
      function drawOverlayContent() {
        const ctx = drawingOverlay.getContext('2d');
        ctx.clearRect(0, 0, drawingOverlay.width, drawingOverlay.height);

        if (drawnShapes.length > 0) {
          const displayW = staticImage.clientWidth;
          const displayH = staticImage.clientHeight;
          drawAllUserShapes(ctx, displayW, displayH, true);
        }
        if (plateImageInMemory) {
          drawPlateOnCanvas(ctx, drawingOverlay.width, drawingOverlay.height, true);
        }
      }

      // ===== 車牌貼上（位置＋縮放） =====
      function drawPlateOnCanvas(ctx, targetW, targetH, isOverlay = false) {
        if (!plateImageInMemory) return;
        const position = platePositionSelect.value || 'bottomRight';
        const scalePercent = (Number(plateScaleInput.value) || 30) / 100;
        const margin = 16;

        const ow = plateImageInMemory.width, oh = plateImageInMemory.height;
        let w = targetW * scalePercent;
        let h = (w / ow) * oh;

        let x, y;
        switch (position) {
          case 'topRight':    x = targetW - w - margin; y = margin; break;
          case 'topLeft':     x = margin; y = margin; break;
          case 'bottomLeft':  x = margin; y = targetH - h - margin; break;
          case 'bottomRight':
          default:            x = targetW - w - margin; y = targetH - h - margin; break;
        }

        ctx.strokeStyle = '#e53935';
        ctx.lineWidth = isOverlay ? 3 : 4;
        ctx.strokeRect(x, y, w, h);
        ctx.drawImage(plateImageInMemory, x, y, w, h);
      }

      // ===== 紅框模式切換 + 紅框選項列 =====
      function toggleDrawingMode() {
        isDrawingMode = !isDrawingMode;
        if (isDrawingMode) {
          drawingModeBtn.textContent = '關閉/清除紅框';
          buildDrawingOptionsIfNeeded();
          const opts = container.querySelector('#drawingOptionsContainer');
          if (opts && opts.style) opts.style.display = 'flex';
          selectionBox.style.display = 'none';
          setupDrawingOverlay();
          drawOverlayContent();
        } else {
          drawingModeBtn.textContent = '開啟紅框編輯';
          const opts = container.querySelector('#drawingOptionsContainer');
          if (opts && opts.style) opts.style.display = 'none';
          clearAllDrawings();
          drawOverlayContent();
        }
      }

      function buildDrawingOptionsIfNeeded() {
        if (container.querySelector('#drawingOptionsContainer')) return;
        const bar = document.createElement('div');
        bar.id = 'drawingOptionsContainer';
        Object.assign(bar.style, {
          display: 'none', background:'var(--panel)', padding:'8px', borderRadius:'6px',
          border: '1px solid var(--border)', marginTop:'6px', gap:'10px', alignItems:'center'
        });
        bar.style.flexWrap = 'wrap';

        // 形狀
        const shapeGroup = document.createElement('div');
        shapeGroup.className = 'row';
        const shapeLabel = document.createElement('label'); shapeLabel.textContent = '形狀'; shapeLabel.style.color = 'var(--fg)';
        drawingShapeSelect = document.createElement('select');
        drawingShapeSelect.id = 'drawingShape';
        drawingShapeSelect.innerHTML = `<option value="rectangle">方框</option><option value="circle">圓框</option>`;
        shapeGroup.append(shapeLabel, drawingShapeSelect);

        // 線寬
        const thickGroup = document.createElement('div'); thickGroup.className = 'row';
        const thickLabel = document.createElement('label'); thickLabel.textContent = '粗細(px)'; thickLabel.style.color = 'var(--fg)';
        lineThicknessInput = document.createElement('input');
        lineThicknessInput.type = 'range'; lineThicknessInput.min = '1'; lineThicknessInput.max = '20'; lineThicknessInput.value = '5';
        const thickValue = document.createElement('span'); thickValue.id = 'thicknessValue'; thickValue.textContent = '5px'; thickValue.style.color = 'var(--fg)';
        lineThicknessInput.addEventListener('input', () => { thickValue.textContent = `${lineThicknessInput.value}px`; });
        thickGroup.append(thickLabel, lineThicknessInput, thickValue);

        // 傾斜（旋轉）
        const rotGroup = document.createElement('div'); rotGroup.className = 'row';
        const rotLabel = document.createElement('label'); rotLabel.textContent = '傾斜'; rotLabel.style.color = 'var(--fg)';
        rotationCheckbox = document.createElement('input'); rotationCheckbox.type = 'checkbox'; rotationCheckbox.id = 'enableRotation';
        rotGroup.append(rotLabel, rotationCheckbox);

        bar.append(shapeGroup, thickGroup, rotGroup);
        // 插入位置：車牌列之後、主畫布之前
        const left = container.querySelector('.editor-left');
        left.insertBefore(bar, left.querySelector('.editor-stage'));
      }

      // ===== 使用者紅框互動 =====
      function startUserDrawing(e) {
        if (!isPrimaryPointer(e)) return;
        e.preventDefault();
        isDrawing = true;
        const rect = drawingOverlay.getBoundingClientRect();
        startX = e.clientX - rect.left;
        startY = e.clientY - rect.top;
        currentShape = {
          type: drawingShapeSelect?.value || 'rectangle',
          thickness: Number(lineThicknessInput?.value || 5),
          startX, startY, endX: startX, endY: startY,
          angle: 0, width: 0, height: 0
        };
      }
      function drawUserMoving(e) {
        if (!isDrawing || !currentShape) return;
        e.preventDefault();
        const rect = drawingOverlay.getBoundingClientRect();
        currentX = e.clientX - rect.left;
        currentY = e.clientY - rect.top;
        const dx = currentX - startX;
        const dy = currentY - startY;
        if (rotationCheckbox?.checked) {
          currentShape.width  = Math.sqrt(dx*dx + dy*dy);
          currentShape.height = currentShape.width * 0.5;
          currentShape.angle  = Math.atan2(dy, dx);
        } else {
          currentShape.width  = Math.abs(dx);
          currentShape.height = Math.abs(dy);
          currentShape.angle  = 0;
        }
        currentShape.endX = currentX;
        currentShape.endY = currentY;
        drawOverlayContent();
        const ctx = drawingOverlay.getContext('2d');
        drawShape(ctx, currentShape, 1, 1);
      }
      function stopUserDrawing() {
        if (!isDrawing || !currentShape) return;
        isDrawing = false;
        if (currentShape.width > dragThreshold && currentShape.height > dragThreshold) {
          drawnShapes.push(currentShape);
        }
        currentShape = null;
        drawOverlayContent();
      }
      function clearAllDrawings() { drawnShapes = []; drawOverlayContent(); }

      // ===== 紅框繪製 =====
      function drawShape(ctx, shape, scaleX, scaleY) {
        ctx.strokeStyle = '#e53935';
        ctx.lineWidth = shape.thickness * scaleX;
        ctx.save();
        const cx = (shape.startX + (shape.endX - shape.startX)/2) * scaleX;
        const cy = (shape.startY + (shape.endY - shape.startY)/2) * scaleY;
        ctx.translate(cx, cy);
        ctx.rotate(shape.angle);
        if (shape.type === 'rectangle') {
          const w = shape.width  * scaleX;
          const h = shape.height * scaleY;
          ctx.strokeRect(-w/2, -h/2, w, h);
        } else if (shape.type === 'circle') {
          const rx = (shape.width/2)  * scaleX;
          const ry = (shape.height/2) * scaleY;
          ctx.scale(1, ry / rx);
          ctx.beginPath(); ctx.arc(0, 0, rx, 0, Math.PI*2); ctx.stroke();
        }
        ctx.restore();
      }
      function drawAllUserShapes(ctx, finalW, finalH, isOverlay = false) {
        if (drawnShapes.length === 0) return;
        let scaleX = 1, scaleY = 1;
        if (!isOverlay) {
          const displayW = staticImage.clientWidth;
          const displayH = staticImage.clientHeight;
          scaleX = finalW / displayW;
          scaleY = finalH / displayH;
        }
        drawnShapes.forEach(s => drawShape(ctx, s, scaleX, scaleY));
      }

      // ===== 生成最終截圖並加入列表 =====
      function generateReportImage() {
        if (!plateImageInMemory) { alert('請先擷取車牌特寫！'); return; }
        if (!videoEl?.src) return;
        videoEl.pause();

        finalCanvas.width  = videoEl.videoWidth;
        finalCanvas.height = videoEl.videoHeight;
        const ctx = finalCanvas.getContext('2d');
        ctx.drawImage(videoEl, 0, 0, finalCanvas.width, finalCanvas.height);

        drawAllUserShapes(ctx, finalCanvas.width, finalCanvas.height, false);
        drawPlateOnCanvas(ctx, finalCanvas.width, finalCanvas.height, false);

        const url = finalCanvas.toDataURL('image/jpeg');
        pushGeneratedItem(url);
      }

      function pushGeneratedItem(url) {
        const ts = Date.now();
        const id = `gen_${ts}_${Math.random().toString(36).slice(2,8)}`;
        const item = { id, url, ts };
        generatedItems.push(item);
        renderGeneratedCard(item);
      }

      function renderGeneratedCard(item) {
        const { id, url, ts } = item;
        const card = document.createElement('div'); card.className = 'generated-image-card';
        const inner = document.createElement('div'); inner.className = 'inner';

        const header = document.createElement('div'); header.className = 'header';
        const info = document.createElement('span'); info.textContent = `產生時間: ${new Date(ts).toLocaleString()}`;

        const btnRow = document.createElement('div'); btnRow.className = 'btn-row';
        const btnRemove = document.createElement('button'); btnRemove.textContent = '移除'; btnRemove.className = 'remove-btn';
        const btnDownload = document.createElement('button'); btnDownload.textContent = '下載'; btnDownload.className = 'download-btn';

        const img = document.createElement('img'); img.src = url; img.id = id;
        btnDownload.onclick = () => downloadImg(id, `report_${new Date(ts).toISOString().slice(0,19).replace(/[-:T]/g,'')}.jpg`);
        btnRemove.onclick = () => removeGeneratedItem(id);
        img.addEventListener('click', () => showPreview(url));

        header.append(info, btnRow);
        btnRow.append(btnRemove, btnDownload);
        inner.append(header, img);
        card.append(inner);
        generatedImagesArea.appendChild(card);
      }

      function rebuildGeneratedList() {
        generatedImagesArea.innerHTML = '';
        generatedItems.forEach(renderGeneratedCard);
      }

      function removeGeneratedItem(id) {
        const idx = generatedItems.findIndex(x => x.id === id);
        if (idx >= 0) generatedItems.splice(idx, 1);
        const el = document.getElementById(id);
        if (el) {
          const card = el.closest('.generated-image-card');
          card?.remove();
        }
      }

      function downloadImg(elementId, filename) {
        const el = document.getElementById(elementId);
        if (!el?.src) return;
        const a = document.createElement('a'); a.download = filename; a.href = el.src; a.click();
      }

      // 浮動大圖預覽
      let previewLayer = null;
      function showPreview(url) {
        if (!previewLayer) {
          previewLayer = document.createElement('div');
          Object.assign(previewLayer.style, {
            position:'fixed', top:'50%', left:'50%', transform:'translate(-50%,-50%)',
            maxWidth:'90vw', maxHeight:'90vh', boxShadow:'0 5px 15px rgba(0,0,0,.3)',
            border:'1px solid var(--border)', zIndex:'9999', display:'none', background: '#0e0f12',
            padding:'8px', borderRadius:'8px'
          });
          const img = document.createElement('img'); img.style.maxWidth='100%'; img.style.maxHeight='80vh'; img.style.borderRadius='4px';
          previewLayer.appendChild(img);
          document.body.appendChild(previewLayer);
          previewLayer.addEventListener('click', hidePreview);
        }
        const img = previewLayer.querySelector('img'); img.src = url;
        previewLayer.style.display = 'block';
      }
      function hidePreview() { if (previewLayer) previewLayer.style.display = 'none'; }

      // 主指標判斷（滑鼠左鍵／第一根手指）
      function isPrimaryPointer(e) { return e.isPrimary !== false; }

      // 載入／替換快照（不重建 UI；不動 isDrawingMode／右側列表等狀態）
      function loadSnapshot(url) {
        if (!container) return;

        snapshotURL = url || '';

        // 1) 設定底圖
        if (!staticImage) return;
        staticImage.src = snapshotURL;
        staticImage.style.display = 'block';

        // 2) 等圖片可用後，建立/刷新 overlay 並重繪
        const onImgReady = () => {
          // 依你原本流程：重新計算 overlay 尺寸與位置，並重繪
          setupDrawingOverlay();
          // 清空已畫紅框
          clearAllDrawings();
          drawOverlayContent();
          // 若先前曾顯示車牌預覽列，可視需要保留或復原
          restorePlatePreviewIfAny?.();
        };
    
        if (staticImage.complete) {
          // 圖片可能已經在快取
          onImgReady();
        } else {
          staticImage.onload = () => {
            staticImage.onload = null;
            onImgReady();
          };
          staticImage.onerror = () => {
            staticImage.onerror = null;
            console.error('載入快照失敗：', snapshotURL);
          };
        }
      }
      // 將初始化狀態以方法暴露，方便外層判斷
      function isReady() {
        return !!initialized;
      }
      // 注意：這裡把回傳物件擴充，讓外部能呼叫 loadSnapshot 與檢查 isReady
      return { init, loadSnapshot, isReady };
    })();

    // 在所有函式宣告之後加上這段「啟動即更新」
    requestAnimationFrame(() => {
      // 第 1 帧：DOM 已排版完成，rail 有正確寬度
      updateSelectionBar();
    });
    // 再保險一帧（某些字型/面板異動會影響初始排版）
    requestAnimationFrame(() => updateSelectionBar());
  </script>
    <!-- 從外部載入違規項目選單 -->
  <script src="./violation_list.js"></script>
</body>
</html>