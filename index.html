<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>違規檢舉小幫手</title>

  <!-- ✅ COI Service Worker -->
  <script src="./coi-serviceworker.min.js"></script>

  <!-- 避免 favicon 404 -->
  <link rel="icon" href="data:," />

  <style>
    /* =========================================================
       Base & Theme Variables
       ========================================================= */
    :root {
      /* 雙滑桿尺寸 */
      --rail-pad: 14px;
      --track-height: 8px;
      --thumb-size: 18px;
      --spacing-v: 18px;
    
      /* 深色主題（預設） */
      --bg: #0e0f12;
      --fg: #e6e6e6;
      --panel: #16181d;
      --border: #262a33;
    
      /* 雙滑桿顏色（深色） */
      --track-bg: #16181d;
      --select-bg: #1e6fd6;
      --accent-color: #35a0ff;
    
      /* 元件色彩 */
      --log-bg: #0a0a0a;
      --log-fg: #86ff91;
      --chip-bg: #0f2338;
      --chip-fg: #bfe3ff;
      --chip-border: #1f3d5e;
      --link-color: #8fbfff;
      --btn-border: var(--border);
      --btn-bg: var(--panel);
      --btn-fg: var(--fg);
      --btn-hover-bg: #222833;
    
      /* 次要文字 */
      --muted-fg: #9aa5b1;
    
      /* 可及性焦點色 */
      --focus-ring: #1e6fd6;
      --focus-ring-light: #2563eb;
      --focus-shadow-alpha: 0.22;
    
      /* 內容最大寬（可依需求調整） */
      --content-max: 960px;
    }
    html { color-scheme: dark light; }

    /* =========================================================
       Light Theme Overrides
       ========================================================= */
    html[data-theme="light"] {
      --bg: #f6f7f9;
      --fg: #111827;
      --panel: #ffffff;
      --border: #d1d5db;
      --track-bg: #ffffff;
      --select-bg: #2563eb;
      --accent-color: #2563eb;
      --log-bg: #f8fafc;
      --log-fg: #0f766e;
      --chip-bg: #e6f0ff;
      --chip-fg: #0b3b77;
      --chip-border: #bfd3ff;
      --link-color: #2563eb;
      --btn-hover-bg: #eef2f7;
      --muted-fg: #6b7280;
      --focus-ring: var(--focus-ring-light);
    }

    /* ====== 按鈕基底 ====== */
    .btn,
    .download-btn,
    .remove-btn {
      appearance: none;
      padding: 6px 14px;
      border-radius: 6px;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg);
      color: var(--btn-fg);
      font-size: 14px;
      cursor: pointer;
      /* 立體感 + 微光澤 */
      box-shadow:
        0 1.5px 3px rgba(0,0,0,0.15),
        inset 0 0 0 rgba(255,255,255,0.12);
      transition:
        background-color .15s ease,
        box-shadow .15s ease,
        transform .1s ease;
    }
    /* ====== hover：浮起來 ====== */
    .btn:hover,
    .download-btn:hover,
    .remove-btn:hover {
      background: var(--btn-hover-bg);
      box-shadow:
        0 3px 6px rgba(0,0,0,0.25),
        inset 0 0 0 rgba(255,255,255,0.2);
      transform: translateY(-1px);
    }
    /* ====== active：按下去 ====== */
    .btn:active,
    .download-btn:active,
    .remove-btn:active {
      transform: translateY(1px);
      box-shadow:
        0 1px 2px rgba(0,0,0,0.2),
        inset 0 0 4px rgba(0,0,0,0.25);
    }

    /* =========================================================
       Theme Toggle
       ========================================================= */
    .theme-toggle input[type="checkbox"] {
      appearance: none;
      width: 30px; height: 10px;
      border-radius: 999px;
      background: #9aa5b1;
      position: relative;
      outline: none;
      cursor: pointer;
      transition: background .2s ease;
      border: 0px solid var(--border);
    }
    .theme-toggle input[type="checkbox"]::after {
      content: "";
      position: absolute;
      top: -4px; left: 0px;
      width: 18px; height: 18px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0,0,0,.2);
      transition: transform .2s ease;
    }
    .theme-toggle input[type="checkbox"]:checked { background: var(--accent-color); }
    .theme-toggle input[type="checkbox"]:checked::after { transform: translateX(18px); }
    .theme-toggle .label { font-size: clamp(10px, 4vw, 13px);; color: inherit; }
    @supports (-webkit-touch-callout: none) {
      .theme-toggle { margin-top: calc(env(safe-area-inset-top) + 8px); }
    }

    /* 父容器：建立定位上下文，並預留右側空間以免 h1 碰到開關 */
    .page-title-bar {
      position: relative;         /* 讓內部 absolute 以此為座標 */
      padding-right: 120px;       /* 預留空間（依你的開關寬度調整） */
      /* 可選：上下留點餘裕 */
      padding-top: 8px;
      padding-bottom: 8px;
    }
    
    /* 標題本身可在窄螢幕換行，避免碰撞 */
    .page-title-bar h1 {
      margin: 0;
      font-weight: 800;
      color: var(--fg);
      white-space: normal;
      overflow-wrap: anywhere;    /* 換行以避免碰到右側開關 */
    }
    
    /* 開關固定在右上角但跟著捲動（因為相對 parent） */
    .page-title-bar .theme-toggle {
      position: absolute;
      top: 50%;
      right: 0px;
      transform: translateY(-70%);  /* 垂直置中；若要貼頂改成 top: 0 即可 */
      z-index: 10;
    
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--fg);
      border-radius: 999px;
      padding: 6px 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,.08);
    }
    
    /* 窄螢幕時縮小右側預留空間與字級，降低碰撞機率 */
    @media (max-width: 420px) {
      .page-title-bar { padding-right: 96px; }
      .page-title-bar h1 { font-size: clamp(16px, 4vw, 24px); }
      .page-title-bar .theme-toggle { right: 0px; }
    }
    
    /* iOS 安全區：避免貼到瀏海或側邊曲面 */
    @supports (-webkit-touch-callout: none) {
      .page-title-bar {
        padding-right: calc(96px + env(safe-area-inset-right));
        padding-top: calc(8px + env(safe-area-inset-top));
      }
    }
    /* =========================================================
       Violation Editor（整合）
       ========================================================= */
    .violation-editor * { box-sizing: border-box; }
    .violation-editor {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial, "PingFang TC", "Microsoft JhengHei", sans-serif;
      color: var(--fg);
      background: var(--panel);
      line-height: 1.5;
      width: min(100%, var(--content-max));
      margin-inline: auto;
      max-width: 100%;
      overflow-x: hidden;
    }
    .violation-editor .toolbar {
      display: flex; flex-wrap: wrap; gap: 10px 14px; align-items: center;
      border: 1px solid var(--border); padding: 12px; border-radius: 6px; background: var(--panel);
      max-width: 100%; overflow: hidden;
    }
    .violation-editor .group { display: inline-flex; align-items: center; gap: 8px; flex: 0 1 auto; min-width: 0; }
    @media (max-width: 640px) { .violation-editor .group.full { flex-basis: 100%; } }
    .violation-editor label { font-size: 14px; color: var(--muted-fg); white-space: nowrap; flex: 0 0 auto; }
    .violation-editor input[type="text"],
    .violation-editor input[type="date"],
    .violation-editor select,
    .violation-editor textarea,
    .violation-editor button {
      border: 1px solid var(--border);
      padding: 6px 8px; font-size: 14px; border-radius: 6px;
      background: var(--panel); color: var(--fg); outline: none;
      min-width: 0; max-width: 100%; box-sizing: border-box;
    }
    .violation-editor :is(input, select, textarea, button):focus-visible {
      border-color: var(--focus-ring);
      box-shadow: 0 0 0 3px rgba(30, 111, 214, var(--focus-shadow-alpha));
    }
    
    /* 車牌輸入框 */
    .violation-editor #ve-plate1, .violation-editor #ve-plate2 { width: 80px; }
    .violation-editor .plate-boxes { display: inline-flex; gap: 8px; align-items: center; min-width: 0; }
    .violation-editor .dash { color: var(--muted-fg); user-select: none; }
    
    /* 時間下拉 */
    .violation-editor .time-selects { display: inline-flex; gap: 8px; align-items: center; min-width: 0; }
    .violation-editor .time-selects select { min-width: 80px; }
    
    /* 預覽／輸出 */
    .violation-editor .preview {
      margin-top: 14px; border: 1px solid var(--border); padding: 12px;
      background: var(--panel); border-radius: 6px; max-width: 100%; overflow: hidden;
    }
    .violation-editor textarea#ve-output {
      width: 100%; height: 140px; font-size: 18px; font-weight: 700;
      border: none; background: transparent; resize: vertical; line-height: 1.7; box-sizing: border-box;
    }
    
    /* 控制列與按鈕 */
    .violation-editor .control-row { display: flex; align-items: center; gap: 12px; margin-top: 8px; flex-wrap: wrap; min-width: 0; }
    .violation-editor .btn { background: var(--panel); color: var(--fg); border-color: var(--border); cursor: pointer; }
    .violation-editor .btn:hover { background: var(--btn-hover-bg); border-color: var(--btn-border); }
    
    /* Light 覆寫（提高對比） */
    html[data-theme="light"] .violation-editor label { color: var(--fg); }
    html[data-theme="light"] .violation-editor input[type="text"],
    html[data-theme="light"] .violation-editor input[type="date"],
    html[data-theme="light"] .violation-editor select,
    html[data-theme="light"] .violation-editor textarea,
    html[data-theme="light"] .violation-editor button {
      background: #ffffff; color: var(--fg); border-color: var(--border);
    }
    html[data-theme="light"] .violation-editor .btn:hover { background: var(--btn-hover-bg); border-color: #bfd3ff; }
    
    /* Select（長字串與 iOS 外觀修正） */
    .violation-editor select {
      -webkit-appearance: none; appearance: none;
      background: var(--panel); color: var(--fg); border: 1px solid var(--border);
      width: 100%; max-width: 100%; box-sizing: border-box;
      white-space: normal; text-overflow: ellipsis; overflow: hidden;
    }
    .violation-editor option { background: var(--panel); color: var(--fg); }
    html[data-theme="light"] .violation-editor select { background: #fff; color: var(--fg); border-color: var(--border); }
    html[data-theme="light"] .violation-editor option { background: #fff; color: var(--fg); }

    /* 違規項目列：左短右長 */
    .violation-editor .violation-row {
      display: flex;
      gap: 8px;
      align-items: center;
      min-width: 0;
    }
    
    .violation-editor #city-select {
      flex: 0 0 auto;
      /* 三～四個中文字寬 + 內距、邊框：你可微調為 6em / 96px / 8ch */
      width: 6.5em;          /* 約等於「台中市」寬度 + 些微空間 */
      max-width: 40%;
    }
    
    .violation-editor #ve-violation {
      flex: 1 1 auto;        /* 吃滿剩餘寬度 */
      min-width: 0;          /* 讓文字可縮、避免溢出 */
    }
    
    /* 小螢幕時縣市再短一點，避免擠壓 */
    @media (max-width: 420px) {
      .violation-editor #city-select { width: 5.5em; }
    }

    /* =========================================================
       Global Base & Components
       ========================================================= */
    * { box-sizing: border-box; }
    body {
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto;
      margin: 2rem;
    }
    @media (max-width: 480px) { body { margin: 1rem; } }
    h1 { margin-top: 0; }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 1rem;
    }
    .controls { display: flex; align-items: center; gap: .5rem; flex-wrap: wrap; }
    .log {
      overflow: auto; word-break: break-word; overflow-wrap: anywhere;
      white-space: pre-wrap; background: var(--log-bg); color: var(--log-fg);
      padding: 1rem; min-height: 10rem; max-height: 40vh; border-radius: 8px; font-size: 0.92rem;
    }
    button {
      padding: .55rem .85rem; border-radius: 8px;
      border: 1px solid var(--btn-border);
      background: var(--btn-bg); color: var(--btn-fg);
      cursor: pointer;
    }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .status { margin:.5rem 0; }
    .time { font-variant-numeric: tabular-nums; }
    .chip {
      background: var(--chip-bg); color: var(--chip-fg);
      border: 1px solid var(--chip-border); padding: .2rem .5rem; border-radius: 6px;
    }
    a { color: var(--link-color); }
    .hint { background: var(--panel); color: var(--fg); font-size: .9rem; }
    .col { display: grid; grid-template-columns: 1fr; gap: 1rem; }
    @media (min-width: 980px) { .col { grid-template-columns: 1.2fr 1fr; } }
    /* 標題顏色 */
    .group-title { margin: .5rem 0 .25rem; font-weight: 600; color: #c9d1d9; }
    html[data-theme="light"] .group-title { color: var(--fg); }

    /* =========================================================
       Media Area & Stacked Slider
       ========================================================= */
    .media-area { padding: 0 var(--rail-pad); }
    .media-area video {
      width: 100%; max-width: 100%; display: block; background: #000; border-radius: 8px;
    }

    .stacked-slider { position: relative; margin-top: .75rem; }
    .stacked-slider .rail {
      position: relative;
      height: calc(var(--spacing-v) * 2 + var(--track-height));
      padding: 0;
    }
    .stacked-slider .track {
      position: absolute; left: 0; right: 0;
      height: var(--track-height); background: var(--track-bg); border-radius: 6px;
    }
    .stacked-slider .track.top { top: 0; }
    .stacked-slider .track.bottom { top: calc(var(--spacing-v) + var(--track-height)); }
    .stacked-slider .selection {
      position: absolute;
      top: calc(var(--spacing-v) / 2 + var(--track-height) / 2);
      height: var(--track-height); background: var(--select-bg);
      border-radius: 6px; pointer-events: none;
    }
    .stacked-slider input[type="range"] {
      position: absolute; left: 0; right: 0; width: 100%;
      margin: 0; background: transparent; -webkit-appearance: none; appearance: none;
      cursor: pointer; height: var(--spacing-v);
    }
    .stacked-slider #startRange { top: 0; }
    .stacked-slider #endRange   { top: var(--spacing-v); }
    .stacked-slider input[type="range"]::-webkit-slider-runnable-track { height: var(--track-height); background: transparent; }
    .stacked-slider input[type="range"]::-moz-range-track { height: var(--track-height); background: transparent; }
    .stacked-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none;
      width: var(--thumb-size); height: var(--thumb-size);
      border-radius: 50%; background: var(--accent-color);
      border: 2px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      margin-top: calc(var(--track-height) / 2 - var(--thumb-size) / 2);
    }
    .stacked-slider input[type="range"]::-moz-range-thumb {
      width: var(--thumb-size); height: var(--thumb-size);
      border-radius: 50%; background: var(--accent-color);
      border: 2px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .stacked-slider input[type="range"]:focus-visible {
      outline: none; box-shadow: 0 0 0 3px rgba(30, 111, 214, var(--focus-shadow-alpha));
    }

    /* Log 折疊控制 */
    .log-panel { display: none; }
    .log-panel.show { display: block; }

    /* =========================================================
       Shot Preview & Generated Items
       ========================================================= */
    /* 主體不再強制修補直式白區（由 EditorLite 注入樣式已修正） */
    .shot-box { display: grid; grid-template-columns: 1fr; gap: .75rem; }
    .shot-preview {
      background: var(--panel); border: 1px solid var(--border);
      min-height: 260px; /* 供桌面端，直式具體高度由 EditorLite 斷點接管 */
      min-width: 100%;
      display: flex; align-items: center; justify-content: center;
      border-radius: 8px; overflow: auto; max-width: 100%;
    }
    .shot-preview img { max-width: 100%; height: auto; display: block; }

    /* =========================================================
       RWD（包含 iPhone 兩欄按鈕）
       ========================================================= */
    @media (max-width: 840px) {
      #shotPreview .editor-grid { grid-template-columns: 1fr; gap: 12px; }
      #shotPreview .tool-row { display: flex; flex-wrap: wrap; gap: 8px; min-width: 0; }
      #shotPreview .tool-row .btn {
        flex: 1 1 calc(50% - 8px); /* 手機預設兩欄 */
        min-width: 140px;
        text-align: center;
      }
      #shotPreview .plate-preview {
        display: flex; flex-direction: column; gap: 10px; padding: 10px;
        background: var(--panel); border: 1px dashed var(--border); border-radius: 8px;
        max-width: 100%; overflow-x: hidden;
      }
      #shotPreview .plate-preview .row { width: 100%; display: flex; align-items: center; gap: 8px; min-width: 0; }
      #shotPreview .plate-preview select, #shotPreview .plate-preview input[type="range"] { flex: 1 1 auto; min-width: 0; }
      #shotPreview .plate-preview img { max-width: 180px; height: auto; }
      #shotPreview #drawingOptionsContainer {
        display: flex; flex-direction: column; gap: 10px;
        background: var(--panel); border: 1px solid var(--border); border-radius: 8px; padding: 10px;
        max-width: 100%; overflow-x: hidden;
      }
      #shotPreview #drawingOptionsContainer .row { width: 100%; display: flex; align-items: center; gap: 8px; min-width: 0; }
      #shotPreview #drawingOptionsContainer select, #shotPreview #drawingOptionsContainer input[type="range"] { flex: 1 1 auto; min-width: 0; }
      #shotPreview .editor-stage { padding: 8px; }
      #staticImageContainer { width: 100%; max-width: 100%; overflow: hidden; }
      #staticImage { max-width: 100%; height: auto; display: block; }
      #shotPreview .editor-stage #drawingOverlay { left: 0; top: 0; width: 100%; height: auto; max-width: 100%; }
      #shotPreview .editor-right {
        max-height: 100%; padding: 10px; background: var(--panel);
        border: 1px solid var(--border); border-radius: 8px; max-width: 100%; overflow-x: hidden;
      }
      #shotPreview #generatedImagesArea { overflow: visible; }
      #shotPreview .generated-image-card { background: var(--panel); border-color: var(--border); border-radius: 8px; padding: 8px; }
      #shotPreview .generated-image-card .inner { background: var(--panel); border-color: var(--border); border-radius: 6px; padding: 6px; }
      #shotPreview .generated-image-card .header { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; min-width: 0; }
      #shotPreview .generated-image-card .btn-row { display: flex; gap: 8px; margin-left: auto; }
      #shotPreview .generated-image-card img { width: 100%; height: auto; display: block; }
    }

    /* iPhone 常見寬度：維持兩欄；超窄退單欄 */
    @media (max-width: 420px) {
      #shotPreview .tool-row { display: flex; flex-wrap: wrap; gap: 8px; overflow: hidden; }
      #shotPreview .tool-row .btn {
        flex: 1 1 calc(50% - 8px);
        min-width: 0; width: auto; white-space: normal;
      }
      .violation-editor .time-selects select { min-width: 0; }
    }
    @media (max-width: 360px) {
      #shotPreview .tool-row .btn { flex: 1 1 100%; min-width: 0; width: 100%; }
      #shotPreview .plate-preview img { max-width: 160px; }
    }

    /* =========================================================
       Hardening（保守保護）
       ========================================================= */
    html, body { overflow-x: hidden; }
    .page, #shotPreview, .violation-editor {
      width: min(100%, var(--content-max)); margin-inline: auto;
    }
    .media-area, .violation-editor, #staticImageContainer, #shotPreview .editor-right {
      max-width: 100%; overflow: hidden;
    }
    img, video, canvas { max-width: 100%; height: auto; display: block; }
    #shotPreview .editor-grid { overflow-x: hidden; }

    .page-title {
      font-size: clamp(16px, 4vw, 24px);
    }
  </style>
</head>
<body>
  <div class="page-title-bar">
    <div class="page-title">
      <h1>違規檢舉小幫手</h1>
    </div>
    <!-- 顯示在畫面最右上角的主題切換開關 -->
    <div class="theme-toggle" role="group" aria-label="主題切換">
      <span class="label" id="themeLabel">深色</span>
      <input type="checkbox" id="themeSwitch" aria-labelledby="themeLabel" />
    </div>
  </div>

  <!-- 檔案選擇與狀態（含「顯示 Log」核取方塊） -->
  <div class="panel">
    <div class="controls">
      <input id="file" type="file" accept="video/*,.ts" />
      <span id="fileInfo" class="hint">請選擇影片（支援 .mp4 / .ts / .mov 等）</span>
    </div>
    <p class="status" id="status" role="status" aria-live="polite">狀態：初始化中…</p>
    <div class="controls">
      <label><input type="checkbox" id="toggleLog" /> 顯示 Log</label>
    </div>
  </div>

  <!-- 主面板：預覽 + 上下雙滑桿 + 按鈕 -->
  <div class="panel">
    <div class="col">
      <!-- 左側：預覽與上下雙滑桿 -->
      <div class="media-area">
        <div>
          <h3>輸出操作</h3>
          <div class="controls">
            <button id="btnClip" class="btn" disabled>剪輯並輸出</button>
            <button id="btnDownloadFull" class="btn" disabled>下載完整轉檔</button>
            <button id="btnThumbnail" class="btn" disabled>擷取縮圖</button>
          </div>
          <p id="out" class="hint"></p>
        </div>

        <video id="preview" controls playsinline></video>
        <div class="time" style="margin-top:.5rem;">
          目前：<span id="cur">00:00:00.00</span> / 片長：<span id="dur">00:00:00.00</span>
        </div>

        <div class="stacked-slider">
          <div class="rail" id="rail">
            <div class="track top"></div>
            <div class="track bottom"></div>
            <div class="selection" id="selection"></div>

            <!-- 上：開始滑桿（初始 0/100） -->
            <input id="startRange" type="range" min="0" max="100" step="0.01" value="0" />
            <!-- 下：結束滑桿（初始就在 100%） -->
            <input id="endRange"   type="range" min="0" max="100" step="0.01" value="100" />
          </div>

          <div class="controls" style="margin-top:.5rem;">
            <span class="chip time" id="startLabel">開始：00:00:00.00</span>
            <span class="chip time" id="endLabel">結束：00:00:00.00</span>
          </div>
        </div>
      </div>

      <!-- 右側：編輯車牌、日期、違規事項區域 -->
      <div>
        <h3 class="group-title">違規資訊</h3>
        <!-- Editor 掛載點（此節點會被 initViolationEditor() 插入內容） -->
        <section id="violation-editor-root"></section>
      </div>
    </div>
  </div>

  <!-- 大型截圖預覽面板 -->
  <div class="panel">
    <h3>截圖預覽</h3>
    <div class="shot-box">
      <div id="shotPreview" class="shot-preview">
        <span class="hint">尚未擷取縮圖</span>
      </div>
    </div>
  </div>

  <!-- Log（預設隱藏；勾選顯示） -->
  <div id="logPanel" class="panel log-panel">
    <h3>Log</h3><button class="btn" id="btnCopyLog">複製</button>
    <div class="log" id="log">Log：</div>
  </div>

  <script type="module">
    /********** 基本 UI **********/
    const statusEl   = document.getElementById('status');
    const logEl      = document.getElementById('log');
    const btnCopyLog = document.getElementById('btnCopyLog');
    const logPanel   = document.getElementById('logPanel');
    const toggleLog  = document.getElementById('toggleLog');
    const fileInput  = document.getElementById('file');
    const fileInfo   = document.getElementById('fileInfo');
    const preview    = document.getElementById('preview');
    const curEl      = document.getElementById('cur');
    const durEl      = document.getElementById('dur');
    const rail       = document.getElementById('rail');
    const selectionEl= document.getElementById('selection');
    const startRange = document.getElementById('startRange');
    const endRange   = document.getElementById('endRange');
    const startLabel = document.getElementById('startLabel');
    const endLabel   = document.getElementById('endLabel');
    const btnClip         = document.getElementById('btnClip');
    const btnDownloadFull = document.getElementById('btnDownloadFull');
    const btnThumbnail    = document.getElementById('btnThumbnail');
    const shotPreviewBox  = document.getElementById('shotPreview');

    toggleLog.addEventListener('change', () => {
      logPanel.classList.toggle('show', toggleLog.checked);
    });

    /********** 主題切換（深色 / 明亮） **********/
    (function setupThemeToggle() {
      const html = document.documentElement;
      const sw = document.getElementById('themeSwitch');
      const lbl = document.getElementById('themeLabel');
      if (!sw || !lbl) return;

      // 根據 localStorage 或系統偏好初始化
      const LS_KEY = 'app-theme';
      const saved = localStorage.getItem(LS_KEY); // 'dark' | 'light' | null
      const sysPrefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;

      let theme = saved || (sysPrefersLight ? 'light' : 'dark');
      applyTheme(theme);

      // 切換事件
      sw.addEventListener('change', () => {
        theme = sw.checked ? 'light' : 'dark';
        applyTheme(theme, true);
      });

      // 套用主題並記錄
      function applyTheme(mode, persist = false) {
        if (mode === 'light') {
          html.setAttribute('data-theme', 'light');
          sw.checked = true;
          lbl.textContent = '明亮';
        } else {
          html.removeAttribute('data-theme');
          sw.checked = false;
          lbl.textContent = '深色';
        }
        if (persist) localStorage.setItem(LS_KEY, mode);
      }
    })();

    const log = (...msgs) => {
      const ts = new Date().toISOString();
      const s = msgs.map(m => { if (typeof m === 'string') return m; try { return JSON.stringify(m); } catch { return String(m); } }).join(' ');
      logEl.textContent += `\n[${ts}] ${s}`;
      logEl.scrollTop = logEl.scrollHeight;
      console.log(...msgs);
    };
    const errlog = (...msgs) => { log('ERROR:', ...msgs); console.error(...msgs); };
    const fmt = (t) => {
      if (!isFinite(t)) return '00:00:00.00';
      const h = Math.floor(t / 3600);
      const m = Math.floor((t % 3600) / 60);
      const s = t % 60;
      return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${s.toFixed(2).padStart(5,'0')}`;
    };
    btnCopyLog.addEventListener('click', async () => {
      const text = logEl.textContent || '';
      try {
        await navigator.clipboard.writeText(text);
        toast('已複製到剪貼簿');
      } catch (err) {
        // 備援方案（Safari、舊瀏覽器）
        const range = document.createRange();
        range.selectNodeContents(logEl);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        document.execCommand('copy');
        sel.removeAllRanges();
        toast('已複製到剪貼簿');
      }
    });

    if ('ResizeObserver' in window && rail) {
      const ro = new ResizeObserver(() => {
        // 只要 rail 寬度有變化（panel 展開 / grid 變更 / 視窗 resize 等），重畫選取色帶
        updateSelectionBar();
      });
      ro.observe(rail);
    }

    /** =========================
     * 違規紀錄編輯器（命名空間版）
     * ========================= */
    function initViolationEditor(root) {
      root.innerHTML = `
        <div class="violation-editor">
          <div class="toolbar" role="group" aria-label="違規資料輸入區">
            <div class="group">
              <label for="ve-plate1">車牌號碼：</label>
              <div class="plate-boxes">
                <input id="ve-plate1" type="text" inputmode="latin" maxlength="4" placeholder="ABCD" aria-label="車牌前段（最多 4 英數字）" />
                <span class="dash">—</span>
                <input id="ve-plate2" type="text" inputmode="latin" maxlength="4" placeholder="1234" aria-label="車牌後段（最多 4 英數字）" />
              </div>
            </div>
    
            <!-- 違規項目 -->
            <div class="group full">
              <label for="ve-violation">違規項目：</label>
              <div class="violation-row" style="display:flex; gap:8px; align-items:center; min-width:0; flex:1 1 auto;">
                <select id="city-select" aria-label="選擇縣市"></select>
                <select id="ve-violation" aria-label="選擇違規項目"></select>
              </div>
            </div>
            <div class="group">
              <label for="ve-date">違規日期：</label>
              <input id="ve-date" type="date" />
            </div>
            <div class="group">
              <label for="ve-hour">違規時間：</label>
              <div class="time-selects" aria-label="違規時間">
                <select id="ve-hour" aria-label="小時"></select>
                <select id="ve-minute" aria-label="分鐘"></select>
              </div>
            </div>
            <div class="group full">
              <label for="ve-road">路段：</label>
              <input id="ve-road" type="text" style="min-width: 240px; flex: 1 1 auto;"
                     value="違規地址" placeholder="請在此填寫違規地址" aria-label="請在此填寫違規地址" />
            </div>
          </div>

          <div class="preview" aria-live="polite">
            <textarea id="ve-output" spellcheck="false"></textarea>
            <div class="control-row">
              <label><input type="checkbox" id="ve-pause"> 暫停自動更新</label>
              <button class="btn" id="ve-copy" type="button" aria-label="複製到剪貼簿">複製到剪貼簿</button>
            </div>
          </div>
        </div>
      `;

      const $ = (sel) => root.querySelector(sel);
      function buildTimeOptions() {
        const hSel = $('#ve-hour'); const mSel = $('#ve-minute');
        hSel.innerHTML = ''; mSel.innerHTML = '';
        for (let h = 0; h <= 23; h++) {
          const opt = document.createElement('option'); opt.value = String(h).padStart(2, '0'); opt.textContent = opt.value; hSel.appendChild(opt);
        }
        for (let m = 0; m <= 59; m++) {
          const opt = document.createElement('option'); opt.value = String(m).padStart(2, '0'); opt.textContent = opt.value; mSel.appendChild(opt);
        }
      }
      function setDefaultDateTime() {
        const now = new Date();
        const yyyy = now.getFullYear();
        const mm = String(now.getMonth() + 1).padStart(2, '0');
        const dd = String(now.getDate()).padStart(2, '0');
        $('#ve-date').value = `${yyyy}-${mm}-${dd}`;
        const rounded = Math.round(now.getMinutes() / 10) * 10;
        $('#ve-hour').value = String(now.getHours()).padStart(2, '0');
        $('#ve-minute').value = String(rounded % 60).padStart(2, '0');
      }
      function sanitizePlate(el) {
        el.addEventListener('input', () => {
          const cleaned = el.value.replace(/[^0-9a-z]/gi, '').toUpperCase().slice(0, 4);
          if (cleaned !== el.value) el.value = cleaned;
          updateOutput();
        });
        el.addEventListener('change', updateOutput);
      }
      function formatDateToYMD(dateStr) {
        if (!dateStr) return '';
        const d = new Date(dateStr + 'T00:00:00'); if (isNaN(d.getTime())) return '';
        const y = d.getFullYear(); const m = String(d.getMonth() + 1).padStart(2, '0'); const day = String(d.getDate()).padStart(2, '0');
        return `${y}/${m}/${day}`;
      }
      function buildText() {
        const p1 = ($('#ve-plate1').value || '');
        const p2 = ($('#ve-plate2').value || '');
        const plate = (p1 || p2) ? `${p1}${p1 && p2 ? '-' : ''}${p2}` : '（車號未填）';
        const d = formatDateToYMD($('#ve-date').value);
        const hh = $('#ve-hour').value || '00';
        const min = $('#ve-minute').value || '00';
        const dt = d ? `${d} ${hh}:${min}` : '（日期/時間未填）';
        const road = ($('#ve-road').value || '').trim() || '請在此填寫違規地址';
        const vioSel = $('#ve-violation'); const vio = vioSel.value || '（尚未選擇違規項目）';
        return `${dt}，車號: ${plate} 於 "${road}"，${vio}。`;
      }

      function updateOutput() {
        if ($('#ve-pause').checked) return;
        $('#ve-output').value = buildText();
      }

      function bindEvents() {
        ['#ve-date','#ve-hour','#ve-minute','#ve-violation','#ve-road'].forEach(sel => {
          root.querySelector(sel).addEventListener('input', updateOutput);
          root.querySelector(sel).addEventListener('change', updateOutput);
        });
        $('#ve-pause').addEventListener('change', function () { if (!this.checked) updateOutput(); });
        $('#ve-copy').addEventListener('click', async () => {
          const text = $('#ve-output').value;
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text); toast('已複製到剪貼簿');
            } else {
              const ta = $('#ve-output'); ta.select(); document.execCommand('copy'); toast('已複製到剪貼簿'); ta.setSelectionRange(ta.value.length, ta.value.length);
            }
          } catch (e) { alert('複製失敗，請手動選取後按 Ctrl+C。'); }
        });
      }
      (function init() {
        buildTimeOptions();
        setDefaultDateTime();
        sanitizePlate($('#ve-plate1'));
        sanitizePlate($('#ve-plate2'));
        bindEvents();
        updateOutput();
      })();
    }
    const veMount = document.getElementById('violation-editor-root');
    if (veMount) initViolationEditor(veMount);
    
    // 在違規編輯器 DOM 建好之後，初始化下拉資料
    if (window.initViolationDropdowns) {
      window.initViolationDropdowns();
    }

    /********** FFmpeg 本地載入（classic worker + wasmBinary） **********/
    const BASE = new URL('.', import.meta.url);
    const CORE_JS   = new URL('./core/ffmpeg-core.js', BASE).href;
    const CORE_WASM = new URL('./core/ffmpeg-core.wasm', BASE).href;
    const WORKER_JS = new URL('./ffmpeg/worker.js', BASE).href;

    const fileToUint8Array = async (fileOrBlob) => new Uint8Array(await fileOrBlob.arrayBuffer());

    // 匯入你本地的 FFmpeg ESM 入口
    let FFmpegCtor;
    let ffmpeg;
    try {
      const mod = await import('./ffmpeg/index.js');
      FFmpegCtor = mod.FFmpeg || mod.default;
    } catch (e) {
      statusEl.textContent = '狀態：載入 FFmpeg 入口失敗 ❌';
      errlog('無法 import ./ffmpeg/index.js：', e?.message || e);
    }

    async function waitSWReady(ms = 5000) {
      try {
        return await Promise.race([
          navigator.serviceWorker.ready,
          new Promise((_, reject) => setTimeout(() => reject(new Error('Service Worker 啟動逾時')), ms))
        ]);
      } catch (e) {
        errlog('Service Worker 可能未就緒：', e?.message || e);
      }
    }

    const startFFmpeg = async () => {
      try {
        statusEl.textContent = '狀態：等待 Service Worker 就緒…';
        await waitSWReady(5000);
        log('crossOriginIsolated =', String(self.crossOriginIsolated));
        ffmpeg = new FFmpegCtor();
        if (ffmpeg?.on) {
          ffmpeg.on('log', ({ message }) => log('[ffmpeg]', message));
          ffmpeg.on('progress', (p) => log('[progress]', JSON.stringify(p)));
        }
        statusEl.textContent = '狀態：正在載入 FFmpeg…（首次載入較慢）';
        await ffmpeg.load({ coreURL: CORE_JS, wasmURL: CORE_WASM, workerURL: WORKER_JS });
        statusEl.textContent = `狀態：FFmpeg 載入完成 ✅`;
        log('FFmpeg 已就緒。');
        setActionsEnabled(false);
      } catch (err) {
        statusEl.textContent = `狀態：載入失敗 ❌ ${err?.message || err}`;
        errlog('初始化失敗：', err?.stack || err);
      }
    };

    await startFFmpeg();

    function toast(msg) {
      const div = document.createElement('div');
      Object.assign(div.style, {
        position: 'fixed', left: '50%', bottom: '24px', transform: 'translateX(-50%)',
        background: '#1d2129', color: '#fff', padding: '8px 12px', borderRadius: '6px',
        fontSize: '14px', zIndex: '9999', border: '1px solid var(--border)'
      });
      div.textContent = msg; document.body.appendChild(div); setTimeout(() => div.remove(), 1200);
    }

    /********** 檔案狀態（TS → 自動重封裝 MP4） **********/
    let selectedFileRaw = null;
    let playableBlob    = null;
    let playableName    = '';
    let autoMp4Blob     = null;
    let autoMp4Url      = '';
    let currentObjectURL = '';
    let FfmpegArgs = ['-i', 'inputfile', '-c', 'copy', '-tag:v', 'hvc1', '-bsf:a', 'aac_adtstoasc', '-movflags', '+faststart', 'automp4.mp4'];

    function revokeURL(url) { try { if (url) URL.revokeObjectURL(url); } catch {} }
    function setActionsEnabled(enabled) {
      btnClip.disabled = !enabled;
      btnDownloadFull.disabled = !enabled;
      btnThumbnail.disabled = !enabled;
    }
    function resetClipUI(dur = 0) {
      if (dur > 0) {
        startRange.min = 0; endRange.min = 0;
        startRange.max = dur; endRange.max = dur;
        startRange.value = 0; endRange.value = dur;
      } else {
        startRange.min = 0; endRange.min = 0;
        startRange.max = 100; endRange.max = 100;
        startRange.value = 0; endRange.value = 100;
      }
      startLabel.textContent = `開始：${fmt(0)}`;
      endLabel.textContent   = `結束：${fmt(dur || 0)}`;
      updateSelectionBar();
      requestAnimationFrame(() => {     // 佈局完成後再保險重畫
        updateSelectionBar();
      });
    }
    function triggerDownloadFromBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    // 小工具：用一次 exec('-i input.ts') 的 log 來判斷 video codec（不轉碼、很快）
    async function detectTsVideoCodec(ffmpeg, inName) {
      return new Promise(async (resolve) => {
        let videoCodec = null;
        const handler = ({ message }) => {
          // 典型行例如： "Video: hevc (Main) ..." / "Video: h264 (High) ..."
          const m = typeof message === 'string' && message.match(/Video:\s*([a-zA-Z0-9_]+)/);
          if (m) videoCodec = m[1].toLowerCase();
        };
        ffmpeg.on && ffmpeg.on('log', handler);
        try {
          // 輕探測。-hide_banner 只為少點雜訊；失敗也沒關係（我們只要 log）
          await ffmpeg.exec(['-hide_banner', '-i', inName]).catch(() => {});
        } finally {
          // 簡單移除監聽（若你的 FFmpeg.on 無 off，可忽略）
          // ffmpeg.off && ffmpeg.off('log', handler);
          resolve(videoCodec); // 可能為 null（解析不到時）
        }
      });
    }

    // ✅ 快照 URL 追蹤與釋放
    let lastSnapshotURL = null;
    fileInput.onchange = async () => {
      const file = fileInput.files?.[0];
      // 清理快照 URL
      if (lastSnapshotURL) { URL.revokeObjectURL(lastSnapshotURL); lastSnapshotURL = null; }

      revokeURL(currentObjectURL); currentObjectURL = '';
      if (!(EditorLite.isReady && EditorLite.isReady())) {
        shotPreviewBox.innerHTML = '<span class="hint">尚未擷取縮圖</span>';
      }

      if (!file) {
        selectedFileRaw = null; playableBlob = null; playableName = '';
        autoMp4Blob = null; autoMp4Url = '';
        setActionsEnabled(false);
        preview.removeAttribute('src'); preview.load();
        fileInfo.textContent = '請選擇影片（支援 .mp4 / .ts / .mov 等）';
        resetClipUI(0);
        return;
      }

      selectedFileRaw = file;
      const lower = (file.name || '').toLowerCase();
      const isTS = lower.endsWith('.ts');

      try {
        if (isTS) {
          const inName = 'input.ts';
          const outName = 'automp4.mp4';
          await ffmpeg.writeFile(inName, await fileToUint8Array(file));
          // 先探測 TS 視訊編碼
          const vCodec = await detectTsVideoCodec(ffmpeg, inName);
          const tagMap = {
            h264: 'avc1',
            avc:  'avc1',
            hevc: 'hvc1',
            h265: 'hvc1'
          };
          const tag = tagMap[vCodec];
          if (!tag) {
            fileInfo.textContent = `不支援的 TS 格式：${vCodec || '未知'}`;
            return;
          }
          FfmpegArgs[1] = inName;
          FfmpegArgs[5] = tag;  // 套用正確的 tag
          FfmpegArgs[FfmpegArgs.length - 1] = outName;
          log('偵測到 TS，執行快速轉換容器為 MP4…', FfmpegArgs);
          await ffmpeg.exec(FfmpegArgs);
          const data = await ffmpeg.readFile(outName);
          autoMp4Blob = new Blob([data.buffer], { type: 'video/mp4' });
          playableBlob = autoMp4Blob;
          playableName = 'input.mp4';
          autoMp4Url   = URL.createObjectURL(autoMp4Blob);
          currentObjectURL = autoMp4Url;
          fileInfo.textContent = `已選擇：${file.name}(${(file.size/1024/1024).toFixed(2)} MB) | 自動重封裝為 MP4`;
          // 清理 FFmpeg 虛擬檔案
          try { await ffmpeg.deleteFile?.(inName); } catch {}
          try { await ffmpeg.deleteFile?.(outName); } catch {}
        } else {
          // 原本邏輯：非 TS 直接預覽
          playableBlob = file;
          playableName = inferInputName(file.name);
          autoMp4Blob  = null; autoMp4Url = '';
          currentObjectURL = URL.createObjectURL(file);
          fileInfo.textContent = `已選擇：${file.name}(${(file.size/1024/1024).toFixed(2)} MB)`;
        }
        preview.src = currentObjectURL;
        preview.load();
        setActionsEnabled(true);
      } catch (e) {
        errlog('載入/轉檔失敗：', e?.message || e);
        alert('載入或自動轉檔失敗：' + (e?.message || e));
        setActionsEnabled(false);
      }
    };

    /********** 預覽時間顯示 **********/
    preview.addEventListener('loadedmetadata', () => {
      const dur = preview.duration;
      durEl.textContent = fmt(dur);
      curEl.textContent = fmt(preview.currentTime || 0);
      resetClipUI(isFinite(dur) ? dur : 0);
    });
    preview.addEventListener('timeupdate', () => {
      curEl.textContent = fmt(preview.currentTime);
    });

    /********** 上下雙滑桿：聯動 + 連動預覽 + 著色選取範圍 **********/
    function updateSelectionBar() {
      const hasDur = isFinite(preview.duration) && preview.duration > 0;
      const rangeMax = hasDur ? preview.duration : parseFloat(startRange.max) || 100;

      let startVal = parseFloat(startRange.value);
      let endVal   = parseFloat(endRange.value);
      if (startVal > endVal) [startVal, endVal] = [endVal, startVal];

      const rect = rail.getBoundingClientRect();
      const innerW = rect.width;

      const startPct = Math.max(0, Math.min(1, startVal / rangeMax));
      const endPct   = Math.max(0, Math.min(1, endVal   / rangeMax));
      const leftPx   = innerW * startPct;
      const widthPx  = innerW * (endPct - startPct);

      selectionEl.style.left  = `${leftPx}px`;
      selectionEl.style.width = `${widthPx}px`;
    }

    const clampAndPreview = (who) => {
      const hasDur = isFinite(preview.duration) && preview.duration > 0;
      let s = parseFloat(startRange.value);
      let e = parseFloat(endRange.value);
      if (who === 'start' && s > e) { endRange.value = s; e = s; }
      if (who === 'end'   && e < s) { startRange.value = e; s = e; }

      startLabel.textContent = `開始：${fmt(hasDur ? s : 0)}`;
      endLabel.textContent   = `結束：${fmt(hasDur ? e : 0)}`;

      if (hasDur) {
        if (who === 'start' && isFinite(s)) preview.currentTime = s;
        if (who === 'end'   && isFinite(e)) preview.currentTime = e;
      }
      updateSelectionBar();
    };
    startRange.addEventListener('input', () => clampAndPreview('start'));
    endRange.addEventListener('input',   () => clampAndPreview('end'));
    window.addEventListener('resize', updateSelectionBar);

    /********** 輔助：推斷輸入檔名（容器名）**********/
    function inferInputName(name) {
      const lower = (name || '').toLowerCase();
      if (lower.endsWith('.mp4')) return 'input.mp4';
      if (lower.endsWith('.ts'))  return 'input.ts';
      if (lower.endsWith('.mov')) return 'input.mov';
      if (lower.endsWith('.mkv')) return 'input.mkv';
      if (lower.endsWith('.mp3')) return 'input.mp3';
      return 'input.mp4';
    }

    /********** 功能 1：剪輯並輸出（不重編碼，-c copy）→ 直接下載 **********/
    btnClip.onclick = async () => {
      try {
        if (!playableBlob) { alert('請先選擇檔案'); return; }

        const s = parseFloat(startRange.value);
        const e = parseFloat(endRange.value);
        if (!isFinite(s) || !isFinite(e)) { alert('請設定開始與結束時間'); return; }
        if (e <= s) { alert('結束時間必須大於開始時間'); return; }

        const inName = playableName || 'input.mp4';
        const outName = 'clip.mp4';

        log('開始快速剪輯（無轉碼）…', { start: s, end: e, inName, outName });
        await ffmpeg.writeFile(inName, await fileToUint8Array(playableBlob));

        const ss = s.toFixed(2);
        const to = e.toFixed(2);
        // 精準（較慢）：-ss 在 -i 之後
        await ffmpeg.exec(['-i', inName, '-ss', ss, '-to', to, '-c', 'copy', outName]);

        const data = await ffmpeg.readFile(outName);
        const blob = new Blob([data.buffer], { type: 'video/mp4' });
        triggerDownloadFromBlob(blob, outName);
        toast(`已下載剪輯檔 (${ss}s → ${to}s)`);
        log('剪輯完成並已觸發下載 ✅');
      } catch (e) {
        errlog('快速剪輯失敗：', e?.message || e);
        alert('剪輯失敗：' + (e?.message || e));
      } finally {
        // 清理暫存檔案
        try { await ffmpeg.deleteFile?.('clip.mp4'); } catch {}
        try {
          const inName = playableName || 'input.mp4';
          await ffmpeg.deleteFile?.(inName);
        } catch {}
      }
    };

    /********** 功能 2：下載完整轉檔 **********/
    btnDownloadFull.onclick = async () => {
      try {
        if (!selectedFileRaw) { alert("請先選擇檔案"); return; }

        const lower = (selectedFileRaw.name || '').toLowerCase();
        const isTS = lower.endsWith('.ts');

        if (isTS) {
          if (autoMp4Blob) {
            triggerDownloadFromBlob(autoMp4Blob, 'converted.mp4');
            toast('已下載自動轉檔 MP4');
            log('TS 已自動轉檔完成，觸發下載 converted.mp4 ✅');
            return;
          }
          const inName = 'input.ts';
          const outName = 'automp4.mp4';
          await ffmpeg.writeFile(inName, await fileToUint8Array(selectedFileRaw));
          FfmpegArgs[1] = inName;
          FfmpegArgs[FfmpegArgs.length - 1] = outName;
          await ffmpeg.exec(FfmpegArgs);
          const data = await ffmpeg.readFile(outName);
          const blob = new Blob([data.buffer], { type: 'video/mp4' });
          triggerDownloadFromBlob(blob, 'converted.mp4');
          toast('已下載自動轉檔 MP4');
          log('TS 重新自動轉檔後觸發下載 ✅');
          try { await ffmpeg.deleteFile?.(inName); } catch {}
          try { await ffmpeg.deleteFile?.(outName); } catch {}
        } else {
          const inName = inferInputName(selectedFileRaw.name);
          await ffmpeg.writeFile(inName, await fileToUint8Array(selectedFileRaw));
          await ffmpeg.exec(['-i', inName, '-movflags', 'faststart', 'output.mp4']);
          const data = await ffmpeg.readFile('output.mp4');
          const blob = new Blob([data.buffer], { type: 'video/mp4' });
          triggerDownloadFromBlob(blob, 'output.mp4');
          toast('已下載自動轉檔 MP4');
          log('完整轉檔完成並已觸發下載 ✅');
          try { await ffmpeg.deleteFile?.(inName); } catch {}
          try { await ffmpeg.deleteFile?.('output.mp4'); } catch {}
        }
      } catch (e) {
        errlog('完整轉檔失敗：', e?.message || e);
        alert('完整轉檔失敗：' + (e?.message || e));
      }
    };

    /********** 功能 3：擷取縮圖 **********/
    btnThumbnail.onclick = async () => {
      try {
        if (!(EditorLite.isReady && EditorLite.isReady())) {
          shotPreviewBox.innerHTML = '<span class="hint">擷取中…</span>';
        }
    
        if (!preview || !preview.videoWidth) {
          alert("影片尚未載入或沒有可用影格");
          shotPreviewBox.innerHTML = '<span class="hint">尚未擷取縮圖</span>';
          return;
        }
        await new Promise((resolve) => {
          if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
            let done = false;
            preview.requestVideoFrameCallback(() => { if (!done) { done = true; resolve(); } });
            if (preview.paused) { done = true; resolve(); }
          } else {
            requestAnimationFrame(() => resolve());
          }
        });
        const w = preview.videoWidth;
        const h = preview.videoHeight;
        const canvas = document.createElement('canvas');
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d');
        const t = preview.currentTime;
        const ss = isFinite(t) ? t.toFixed(2) : '0';
    
        if ('createImageBitmap' in window) {
          try {
            const bmp = await createImageBitmap(preview);
            ctx.drawImage(bmp, 0, 0, w, h);
            bmp.close?.();
          } catch {
            ctx.drawImage(preview, 0, 0, w, h);
          }
        } else {
          ctx.drawImage(preview, 0, 0, w, h);
        }
    
        const blob = await new Promise((resolve, reject) =>
          canvas.toBlob(b => b ? resolve(b) : reject(new Error('toBlob 失敗')), 'image/png', 0.92)
        );
        const url = URL.createObjectURL(blob);

        // 釋放上一張快照 URL
        if (lastSnapshotURL && lastSnapshotURL !== url) {
          URL.revokeObjectURL(lastSnapshotURL);
        }
        lastSnapshotURL = url;

        // 顯示到你保留的 #shotPreview（不新增任何外部節點/屬性）
        if (!(EditorLite.isReady && EditorLite.isReady())) {
          shotPreviewBox.innerHTML = '';
          const img = document.createElement('img');
          img.src = url;
          img.alt = `縮圖（${ss}s）`;
          img.loading = 'lazy';
          img.decoding = 'async';
          shotPreviewBox.appendChild(img);
        }
        toast(`已擷取縮圖（${ss}s）`);
        log('Canvas 擷取完成 ✅', { currentTime: ss, width: w, height: h });

        // 初始化或僅換底圖（避免重建 UI 造成狀態不同步）
        if (EditorLite.isReady && EditorLite.isReady()) {
          // 已經初始化過僅換底圖
          EditorLite.loadSnapshot(url);
        } else {
          // 第一次初始化
          EditorLite.init(shotPreviewBox, { videoEl: preview, snapshotURL: url });
        }
      } catch (e) {
        shotPreviewBox.innerHTML = '<span class="hint">尚未擷取縮圖</span>';
        errlog('擷取縮圖失敗：', e?.message || e);
        alert('擷取縮圖失敗：' + (e?.message || e));
      }
    };

    /*** === EditorLite 模組（最小整合到 #shotPreview）=== ***/
    (function ensureEditorLiteStyles() {
      const id = 'editorlite-styles';
      const el = document.getElementById(id);
      if (el) { return; }
      const style = document.createElement('style');
      style.id = id;
      style.textContent = `
        #shotPreview .editor-grid {
          display: grid;
          grid-template-columns: minmax(0, 1fr) 340px;
          grid-auto-rows: auto;
          gap: 14px;
          align-items: start;
        }
        #shotPreview .editor-left { display: flex; flex-direction: column; gap: 10px; }
        #shotPreview .editor-header { display: flex; align-items: center; gap: 12px; }
        #shotPreview .editor-header h3 { margin: 0; font-weight: 600; color: var(--fg); }
        #shotPreview .tool-row { display: flex; gap: 8px; flex-wrap: wrap; }
        #shotPreview .tool-row .btn {
          padding: 8px 12px; border: 1px solid var(--border);
          background: var(--panel); color: var(--fg);
          border-radius: 6px; cursor: pointer; font-weight: 600;
        }
        #shotPreview .tool-row .btn:hover { background: var(--panel); }
        #shotPreview .editor-stage {
          position: relative;
          background: var(--panel);
          border: 1px solid var(--border);
          border-radius: 8px;
          padding: 10px;
          min-height: clamp(120px, 40vw, 360px);
        }
        @media (orientation: portrait) {
          #shotPreview .editor-stage {
            min-height: 0;
            padding-bottom: 8px;
          }
        }
        #shotPreview #staticImageContainer { position: relative; }
        #shotPreview #staticImage { max-width: 100%; height: auto; display: block; }
        #shotPreview #drawingOverlay {
          position: absolute; left: 0; top: 0;
          display: none; pointer-events: auto;
        }
        #shotPreview #selectionBox {
          position: absolute; border: 2px solid #e53935;
          background: rgba(229,57,53,.12); display: none;
          border-radius: 4px;
        }
        #shotPreview .plate-preview {
          display: none; gap: 10px; align-items: center; padding: 8px;
          border: 1px dashed var(--border); border-radius: 6px; background: var(--panel);
        }
        #shotPreview .plate-preview img { border: 2px solid #e53935; max-width: 150px; height: auto; }
        #shotPreview .plate-preview .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        #shotPreview .plate-preview label { color: var(--fg); }
        #shotPreview .editor-right {
          border: 1px solid var(--border); border-radius: 8px; padding: 10px; background: var(--panel);
          display: flex; flex-direction: column; gap: 8px;
          max-height: 100%;
        }
        #shotPreview .editor-right h3 { margin: 0; font-weight: 600; color: var(--fg); }
        #shotPreview #generatedImagesArea {
          display: flex; flex-direction: column; gap: 12px;
          overflow: auto; flex: 1;
        }
        #shotPreview .generated-image-card {
          border: 1px solid var(--border); border-radius: 8px; padding: 8px;
          background: var(--panel);
        }
        #shotPreview .generated-image-card .inner {
          border: 1px solid var(--border); border-radius: 6px; padding: 6px; background: var(--panel);
        }
        #shotPreview .generated-image-card .header {
          display: flex; gap: 8px; align-items: center; justify-content: space-between; margin-bottom: 6px; color: var(--fg);
        }
        #shotPreview .generated-image-card .btn-row { display: flex; gap: 8px; }
        #shotPreview .generated-image-card img { max-width: 100%; height: auto; cursor: pointer; border-radius: 4px; }
        #shotPreview .generated-image-card .download-btn,
        #shotPreview .generated-image-card .remove-btn {
          padding: 6px 10px; border: 1px solid var(--border); background: var(--panel); color: var(--fg); border-radius: 6px;
          white-space: nowrap;
        }
        #shotPreview .generated-image-card .download-btn:hover,
        #shotPreview .generated-image-card .remove-btn:hover { background: var(--panel); }
  
        @media (max-width: 840px) {
          #shotPreview .editor-grid { grid-template-columns: 1fr; }
        }
      `;
      document.head.appendChild(style);
    })();

    function isIOSMobile() {
      const ua = navigator.userAgent || '';
      const iOSClassic = /iPhone|iPod/.test(ua);
      const iPadOS = (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      const iPadClassic = /iPad/.test(ua);
      return iOSClassic || iPadOS || iPadClassic;
    }

    // ================= EditorLite 主體 =================
    const EditorLite = (() => {
      /* ===== Module-scope Variables ===== */
      let initialized = false;
      let container = null;
      let videoEl = null;
      let snapshotURL = '';

      let staticImageContainer = null;
      let staticImage = null;
      let selectionBox = null;
      let drawingOverlay = null;

      let platePreviewArea = null;
      let plateImg = null;
      let platePositionSelect = null;
      let plateScaleInput = null;

      let generatedImagesArea = null;
      const generatedItems = []; // {id, url, ts}

      const finalCanvas = document.createElement('canvas');

      let startX = 0, startY = 0, currentX = 0, currentY = 0;
      let isDrawing = false;
      let finalCropCoords = {};
      const dragThreshold = 5;

      let drawnShapes = [];
      let currentShape = null;

      // Tools state
      let toolMode = 'shape';          // 'plate' | 'shape' | 'text' | 'mosaic'
      let lastNonPlateTool = 'shape';
      let overlayInteractive = true;

      // Text + Mosaic
      let textItems = [];              // { id, x, y, text, font, fill, stroke?, align?, baseline? }
      let mosaicItems = [];            // { id, rect:{x,y,w,h}, block }
      let isMosaicDrawing = false;
      let mosaicCurrent = null;        // {startX,startY,endX,endY, rect, block}
      let plateImageInMemory = null;
      // Text dragging state
      let isTextDragging = false;
      let dragText = null;               // 命中的文字項目（物件本身）
      let dragStartX = 0, dragStartY = 0;
      let dragOrigX = 0, dragOrigY = 0;
      const textDragThreshold = 5;       // 小於此像素視為「點一下」→ 進入編輯

      // Options UI elements
      let toolSelect = null;
      let textSize = null;
      let textColor = null;
      let mosaicRange = null;
      let drawingShapeSelect = null;
      let lineThicknessInput = null;
      let rotationCheckbox = null;
      let shapeGroup = null, thickGroup = null, rotGroup = null, textGroup = null, mosaicGroup = null;

      // Text editor
      let activeTextEditor = null;
      let editingTextId = null;

      // Misc
      let keybound = false;
      let previewLayer = null;
      let overlayEventsBound = false;

      /* ===== Utilities ===== */
      function isPrimaryPointer(e) { return e.isPrimary !== false; }
      function getTextSize() { return (textSize?.value | 0) || 18; }
      function getTextColor() { return textColor?.value || '#ff2d55'; }

      function setOverlayInteractive(enabled) {
        overlayInteractive = !!enabled;
        if (drawingOverlay) drawingOverlay.style.pointerEvents = overlayInteractive ? 'auto' : 'none';
      }

      function setTool(mode) {
        toolMode = mode;
        if (mode !== 'plate') lastNonPlateTool = mode;
        setOverlayInteractive(mode !== 'plate');
        if (toolSelect && toolSelect.value !== mode) toolSelect.value = mode;
        updateToolOptionsVisibility();
        drawingOverlay.style.cursor = (mode === 'text' && drawingOverlay)? 'text': 'crosshair';
      }

      function updateToolOptionsVisibility() {
        const show = (el, on) => { if (el) el.style.display = on ? 'flex' : 'none'; };
        show(shapeGroup,  toolMode === 'shape');
        show(thickGroup,  toolMode === 'shape');
        show(rotGroup,    toolMode === 'shape');
        show(textGroup,   toolMode === 'text');
        show(mosaicGroup, toolMode === 'mosaic');
        if (toolMode === 'plate') {
          show(shapeGroup, false);
          show(thickGroup, false);
          show(rotGroup, false);
          show(textGroup, false);
          show(mosaicGroup, false);
        }
      }

      /* ===== Public: init / loadSnapshot / isReady ===== */
      function init(host, { videoEl: v, snapshotURL: url } = {}) {
        container = host;
        videoEl = v;
        snapshotURL = url || '';
        container.innerHTML = '';

        // Grid + left pane
        const grid = document.createElement('div'); grid.className = 'editor-grid';
        const left = document.createElement('section'); left.className = 'editor-left';

        // Header buttons
        const header = document.createElement('div'); header.className = 'editor-header';
        const h3 = document.createElement('h3'); h3.textContent = '';
        const btnClearEdits = document.createElement('button');
        btnClearEdits.textContent = '清除所有編輯'; btnClearEdits.className = 'btn'; btnClearEdits.onclick = clearAllEdits;

        const btnUndo = document.createElement('button');
        btnUndo.textContent = '撤銷 (Ctrl+Z)'; btnUndo.className = 'btn'; btnUndo.onclick = undoLastShape;

        const btnGenerate = document.createElement('button');
        btnGenerate.textContent = '產生最終截圖'; btnGenerate.className = 'btn'; btnGenerate.onclick = generateReportImage;

        const toolRow = document.createElement('div'); toolRow.className = 'tool-row';
        toolRow.append(btnClearEdits, btnUndo, btnGenerate);
        header.append(h3, toolRow);
        left.appendChild(header);

        // Plate preview row
        platePreviewArea = document.createElement('div'); platePreviewArea.className = 'plate-preview';
        const plateLabel = document.createElement('span'); plateLabel.textContent = '車牌預覽：'; plateLabel.style.color = 'var(--fg)';
        plateImg = document.createElement('img'); plateImg.alt = '車牌預覽圖'; plateImg.style.display = 'none';

        const posGroup = document.createElement('div'); posGroup.className = 'row';
        const posLabel = document.createElement('label'); posLabel.textContent = '位置';
        platePositionSelect = document.createElement('select');
        ['bottomRight','topRight','bottomLeft','topLeft'].forEach(v => {
          const opt = document.createElement('option'); opt.value = v;
          opt.textContent = ({bottomRight:'右下角', topRight:'右上角', bottomLeft:'左下角', topLeft:'左上角'})[v];
          platePositionSelect.appendChild(opt);
        });

        const scaleGroup = document.createElement('div'); scaleGroup.className = 'row';
        const scaleLabel = document.createElement('label'); scaleLabel.textContent = '縮放(%)';
        plateScaleInput = document.createElement('input'); plateScaleInput.type = 'range'; plateScaleInput.min = '10'; plateScaleInput.max = '50'; plateScaleInput.value = '30';
        const scaleValue = document.createElement('span'); scaleValue.id = 'scaleValue'; scaleValue.textContent = '30%';

        plateScaleInput.addEventListener('input', () => { scaleValue.textContent = `${plateScaleInput.value}%`; drawOverlayContent(); });
        platePositionSelect.addEventListener('change', drawOverlayContent);

        posGroup.append(posLabel, platePositionSelect);
        scaleGroup.append(scaleLabel, plateScaleInput, scaleValue);
        platePreviewArea.append(plateLabel, plateImg, posGroup, scaleGroup);
        left.appendChild(platePreviewArea);

        // Stage
        const stage = document.createElement('div'); stage.className = 'editor-stage';
        staticImageContainer = document.createElement('div');
        staticImageContainer.id = 'staticImageContainer';
        staticImageContainer.style.cursor = 'crosshair';
        staticImageContainer.style.touchAction = 'none';

        staticImage = document.createElement('img');
        staticImage.id = 'staticImage';
        staticImage.alt = '靜態截圖預覽';
        staticImage.style.display = 'none';

        selectionBox = document.createElement('div'); selectionBox.id = 'selectionBox';
        drawingOverlay = document.createElement('canvas'); drawingOverlay.id = 'drawingOverlay';

        staticImageContainer.append(staticImage, selectionBox, drawingOverlay);
        stage.appendChild(staticImageContainer);
        left.appendChild(stage);

        // Right pane
        const right = document.createElement('aside'); right.className = 'editor-right';
        const headerBar = document.createElement('div');
        headerBar.style.display = 'flex';
        headerBar.style.alignItems = 'center';
        headerBar.style.justifyContent = 'space-between';
        headerBar.style.gap = '8px';

        const rh3 = document.createElement('h3'); rh3.textContent = '截圖列表';

        const clearShotsBtn = document.createElement('button');
        clearShotsBtn.textContent = '全部清除'; clearShotsBtn.className = 'remove-btn';
        clearShotsBtn.style.whiteSpace = 'nowrap'; clearShotsBtn.onclick = clearAllGenerated;

        const downloadAllBtn = document.createElement('button');
        downloadAllBtn.textContent = '全部下載'; downloadAllBtn.className = 'download-btn';
        downloadAllBtn.style.whiteSpace = 'nowrap'; downloadAllBtn.onclick = DownloadIndividually;
        if (isIOSMobile()) downloadAllBtn.style.display = 'none';

        const btnGroup = document.createElement('div'); btnGroup.style.display = 'flex'; btnGroup.style.gap = '8px';
        btnGroup.append(clearShotsBtn, downloadAllBtn);
        headerBar.append(rh3, btnGroup);

        generatedImagesArea = document.createElement('div'); generatedImagesArea.id = 'generatedImagesArea';
        right.append(headerBar, generatedImagesArea);

        // Assemble
        grid.append(left, right);
        container.appendChild(grid);

        // Build tool options (after DOM in place)
        buildDrawingOptionsIfNeeded();

        // Hotkeys: undo
        if (!keybound) {
          keybound = true;
          window.addEventListener('keydown', (e) => {
            const isZ = (e.key === 'z' || e.key === 'Z');
            const withCmd = e.metaKey || e.ctrlKey;
            if (withCmd && isZ) { e.preventDefault(); undoLastShape(); }
          });
        }

        // Preload snapshot
        if (snapshotURL) {
          staticImage.src = snapshotURL;
          staticImage.style.display = 'block';
          setupDrawingOverlay();
        }

        rebuildGeneratedList();
        restorePlatePreviewIfAny();
        syncRightHeightWithLeft();
        disableRightPaneHeightOnMobile();
        initialized = true;
      }

      function loadSnapshot(url) {
        if (!container) return;
        snapshotURL = url || '';
        if (!staticImage) return;
        staticImage.src = snapshotURL;
        staticImage.style.display = 'block';

        const onImgReady = () => {
          setupDrawingOverlay();
          clearAllDrawings();
          drawOverlayContent();
          restorePlatePreviewIfAny?.();
        };

        if (staticImage.complete) onImgReady();
        else {
          staticImage.onload = () => { staticImage.onload = null; onImgReady(); };
          staticImage.onerror = () => { staticImage.onerror = null; console.error('載入快照失敗：', snapshotURL); };
        }
      }

      function isReady() { return !!initialized; }

      /* ===== Toolbar: Build Options ===== */
      function buildDrawingOptionsIfNeeded() {
        if (container.querySelector('#drawingOptionsContainer')) return;
        // Groups
        shapeGroup = document.createElement('div'); shapeGroup.className = 'row'; shapeGroup.id = 'opt-shape';
        thickGroup = document.createElement('div'); thickGroup.className = 'row'; thickGroup.id = 'opt-thick';
        rotGroup   = document.createElement('div'); rotGroup.className   = 'row'; rotGroup.id   = 'opt-rot';
        textGroup  = document.createElement('div'); textGroup.className  = 'row'; textGroup.id  = 'opt-text';
        mosaicGroup= document.createElement('div'); mosaicGroup.className= 'row'; mosaicGroup.id= 'opt-mosaic';

        // Shape
        const shapeLabel = document.createElement('label'); shapeLabel.textContent = '形狀'; shapeLabel.style.color = 'var(--fg)';
        drawingShapeSelect = document.createElement('select'); drawingShapeSelect.id = 'drawingShape';
        drawingShapeSelect.innerHTML = `<option value="rectangle">方框</option><option value="circle">圓框</option>`;
        shapeGroup.append(shapeLabel, drawingShapeSelect);

        // Thickness
        const thickLabel = document.createElement('label'); thickLabel.textContent = '粗細(px)'; thickLabel.style.color = 'var(--fg)';
        lineThicknessInput = document.createElement('input');
        lineThicknessInput.type = 'range'; lineThicknessInput.min = '1'; lineThicknessInput.max = '20'; lineThicknessInput.value = '5';
        const thickValue = document.createElement('span'); thickValue.id = 'thicknessValue'; thickValue.textContent = '5px'; thickValue.style.color = 'var(--fg)';
        lineThicknessInput.addEventListener('input', () => { thickValue.textContent = `${lineThicknessInput.value}px`; });
        thickGroup.append(thickLabel, lineThicknessInput, thickValue);

        // Rotation
        const rotLabel = document.createElement('label'); rotLabel.textContent = '傾斜'; rotLabel.style.color = 'var(--fg)';
        rotationCheckbox = document.createElement('input'); rotationCheckbox.type = 'checkbox'; rotationCheckbox.id = 'enableRotation';
        rotGroup.append(rotLabel, rotationCheckbox);

        // Tool selector
        const toolGroup = document.createElement('div'); toolGroup.className = 'row';
        const toolLabel = document.createElement('label'); toolLabel.textContent = '工具'; toolLabel.style.color = 'var(--fg)';
        toolSelect = document.createElement('select'); toolSelect.id = 'toolMode';
        toolSelect.innerHTML = `
          <option value="plate">選取車牌</option>
          <option value="shape">紅框</option>
          <option value="text">文字</option>
          <option value="mosaic">馬賽克</option>
        `;
        toolSelect.addEventListener('change', () => { setTool(toolSelect.value); updateToolOptionsVisibility(); });
        toolGroup.append(toolLabel, toolSelect);

        // Text options
        const textLabel = document.createElement('label'); textLabel.textContent = '文字樣式'; textLabel.style.color = 'var(--fg)';
        textSize = document.createElement('input'); textSize.type = 'number'; textSize.min = '8'; textSize.max = '96'; textSize.value = '18'; textSize.style.width = '64px';
        textColor = document.createElement('input'); textColor.type = 'color'; textColor.value = '#ff2d55';
        textGroup.append(textLabel, textSize, textColor);

        // Mosaic options
        const mosaicLabel = document.createElement('label'); mosaicLabel.textContent = '馬賽克'; mosaicLabel.style.color = 'var(--fg)';
        mosaicRange = document.createElement('input'); mosaicRange.type = 'range'; mosaicRange.min = '4'; mosaicRange.max = '48'; mosaicRange.value = '12';
        const mosaicVal = document.createElement('span'); mosaicVal.textContent = '12px'; mosaicVal.style.color = 'var(--fg)';
        mosaicRange.addEventListener('input', () => (mosaicVal.textContent = `${mosaicRange.value}px`));
        mosaicGroup.append(mosaicLabel, mosaicRange, mosaicVal);

        // Bar
        const bar = document.createElement('div');
        bar.id = 'drawingOptionsContainer';
        Object.assign(bar.style, {
          display: 'flex', background: 'var(--panel)', padding: '8px', borderRadius: '6px',
          border: '1px solid var(--border)', marginTop: '6px', gap: '10px', alignItems: 'center', flexWrap: 'wrap'
        });
        bar.append(toolGroup, shapeGroup, thickGroup, rotGroup, textGroup, mosaicGroup);

        const left = container.querySelector('.editor-left');
        left.insertBefore(bar, left.querySelector('.editor-stage'));

        toolSelect.value = 'shape';
        setTool('shape');
        updateToolOptionsVisibility();
      }

      /* ===== Overlay: Size + Events ===== */
      function setupDrawingOverlay() {
        if (staticImage.style.display === 'none') return;

        const r = staticImage.getBoundingClientRect();
        const base = staticImageContainer.getBoundingClientRect();
        drawingOverlay.width = r.width;
        drawingOverlay.height = r.height;
        drawingOverlay.style.left = `${r.left - base.left}px`;
        drawingOverlay.style.top = `${r.top - base.top}px`;
        drawingOverlay.style.touchAction = 'none';
        drawingOverlay.style.display = 'block';
        drawingOverlay.style.pointerEvents = overlayInteractive ? 'auto' : 'none';

        if (!overlayEventsBound) {
          drawingOverlay.addEventListener('pointerdown', (e) => {
            if (!isPrimaryPointer(e) || toolMode === 'plate') return;
            e.preventDefault(); e.stopPropagation();
            if (toolMode === 'shape')  startUserDrawing(e);
            else if (toolMode === 'mosaic') startMosaic(e, mosaicRange ? Number(mosaicRange.value) : 12);
            else if (toolMode === 'text') onTextPointerDown(e);
          });

          drawingOverlay.addEventListener('pointermove', (e) => {
            if (!isPrimaryPointer(e) || toolMode === 'plate') return;
            if (toolMode === 'shape')  drawUserMoving(e);
            else if (toolMode === 'mosaic') drawMosaicMoving(e);
            else if (toolMode === 'text') onTextPointerMove(e);
          });

          drawingOverlay.addEventListener('pointerup', (e) => {
            if (!isPrimaryPointer(e) || toolMode === 'plate') return;
            if (toolMode === 'shape')  stopUserDrawing(e);
            else if (toolMode === 'mosaic') stopMosaic(e);
            else if (toolMode === 'text') onTextPointerUp(e);
          });

          drawingOverlay.addEventListener('pointercancel', (e) => {
            if (!isPrimaryPointer(e) || toolMode === 'plate') return;
            if (toolMode === 'shape')  stopUserDrawing(e);
            else if (toolMode === 'mosaic') stopMosaic(e);
            else if (toolMode === 'text') onTextPointerUp(e);
          });

          staticImageContainer.addEventListener('pointerdown', onSelectStart, { passive: false });
          staticImageContainer.addEventListener('pointermove', onSelectMove,   { passive: false });
          staticImageContainer.addEventListener('pointerup',   onSelectEnd,    { passive: false });
          staticImageContainer.addEventListener('pointercancel', onSelectEnd,  { passive: false });
          overlayEventsBound = true;
        }

        drawOverlayContent();

        if ('ResizeObserver' in window) {
          const ro = new ResizeObserver(() => {
            const rr = staticImage.getBoundingClientRect();
            const bb = staticImageContainer.getBoundingClientRect();
            drawingOverlay.width = rr.width;
            drawingOverlay.height = rr.height;
            drawingOverlay.style.left = `${rr.left - bb.left}px`;
            drawingOverlay.style.top  = `${rr.top  - bb.top}px`;
            drawOverlayContent();
          });
          ro.observe(staticImageContainer);
        }
      }

      /* ===== Tool: Undo / Clear Edits ===== */
      function undoLastShape() {
        if (textItems.length)     { textItems.pop(); drawOverlayContent(); return; }
        if (mosaicItems.length)   { mosaicItems.pop(); drawOverlayContent(); return; }
        if (drawnShapes.length)   { drawnShapes.pop(); drawOverlayContent(); return; }
      }

      function clearAllEdits() {
        if (activeTextEditor) {
          try { activeTextEditor.onblur = null; document.body.removeChild(activeTextEditor); } catch {}
          activeTextEditor = null;
          editingTextId = null;
        }
        drawnShapes = [];
        mosaicItems = [];
        textItems = [];
        isDrawing = false;
        currentShape = null;
        isMosaicDrawing = false;
        mosaicCurrent = null;
        try { clearPlateCrop(); } catch {}
        if (selectionBox) selectionBox.style.display = 'none';
        setOverlayInteractive(true);
        setTool('shape');
        drawOverlayContent();
      }

      /* ===== Right Pane: List Ops ===== */
      function clearAllGenerated() {
        if (!generatedItems.length) { alert('目前沒有可清除的截圖'); return; }
        const ok = confirm('確定要刪除所有截圖嗎？此動作無法復原。');
        if (!ok) return;
        generatedItems.length = 0;
        if (generatedImagesArea) generatedImagesArea.innerHTML = '';
      }

      function DownloadIndividually() {
        if (!generatedItems.length) { alert('目前沒有可下載的截圖'); return; }
        generatedItems.forEach((item, idx) => {
          const ts = new Date(item.ts || Date.now()).toISOString().slice(0,19).replace(/[-:T]/g,'');
          const fileName = `report_${ts}_${idx + 1}.jpg`;
          const a = document.createElement('a'); a.download = fileName; a.href = item.url;
          document.body.appendChild(a); a.click(); a.remove();
        });
      }

      function pushGeneratedItem(url) {
        const ts = Date.now();
        const id = `gen_${ts}_${Math.random().toString(36).slice(2,8)}`;
        const item = { id, url, ts };
        generatedItems.push(item);
        renderGeneratedCard(item);
      }

      function renderGeneratedCard(item) {
        const { id, url, ts } = item;
        const card = document.createElement('div'); card.className = 'generated-image-card';
        const inner = document.createElement('div'); inner.className = 'inner';
        const header = document.createElement('div'); header.className = 'header';
        const info = document.createElement('span'); info.textContent = `產生時間: ${new Date(ts).toLocaleString()}`;
        const btnRow = document.createElement('div'); btnRow.className = 'btn-row';
        const btnRemove = document.createElement('button'); btnRemove.textContent = '移除'; btnRemove.className = 'remove-btn';
        const btnDownload = document.createElement('button'); btnDownload.textContent = '下載'; btnDownload.className = 'download-btn';
        const img = document.createElement('img'); img.src = url; img.id = id;
        btnDownload.onclick = () => downloadImg(id, `report_${new Date(ts).toISOString().slice(0,19).replace(/[-:T]/g,'')}.jpg`);
        btnRemove.onclick = () => removeGeneratedItem(id);
        img.addEventListener('click', () => showPreview(url));
        header.append(info, btnRow);
        btnRow.append(btnRemove, btnDownload);
        inner.append(header, img);
        card.append(inner);
        generatedImagesArea.appendChild(card);
      }

      function rebuildGeneratedList() {
        generatedImagesArea.innerHTML = '';
        generatedItems.forEach(renderGeneratedCard);
      }

      function removeGeneratedItem(id) {
        const idx = generatedItems.findIndex(x => x.id === id);
        if (idx >= 0) generatedItems.splice(idx, 1);
        const el = document.getElementById(id);
        if (el) el.closest('.generated-image-card')?.remove();
      }

      function downloadImg(elementId, filename) {
        const el = document.getElementById(elementId);
        if (!el?.src) return;
        const a = document.createElement('a'); a.download = filename; a.href = el.src;
        document.body.appendChild(a); a.click(); a.remove();
      }

      /* ===== Left/Right Sync + Mobile ===== */
      function syncRightHeightWithLeft() {
        const leftStage = container.querySelector('.editor-left');
        const rightPane = container.querySelector('.editor-right');
        if (!leftStage || !rightPane) return;
        rightPane.style.height = `${leftStage.offsetHeight}px`;
        if ('ResizeObserver' in window) {
          const ro = new ResizeObserver(() => { rightPane.style.height = `${leftStage.offsetHeight}px`; });
          ro.observe(leftStage);
        } else {
          window.addEventListener('resize', () => { rightPane.style.height = `${leftStage.offsetHeight}px`; });
        }
      }

      function disableRightPaneHeightOnMobile() {
        const mq = window.matchMedia('(max-width: 840px)');
        const rightPane = container.querySelector('.editor-right');
        const apply = () => {
          if (!rightPane) return;
          rightPane.style.height = mq.matches ? 'auto' : rightPane.style.height;
        };
        apply();
        if (mq.addEventListener) mq.addEventListener('change', apply);
        else mq.addListener && mq.addListener(apply);
      }

      /* ===== Plate Selection (plate tool) ===== */
      function onSelectStart(e) {
        if (!isPrimaryPointer(e) || toolMode !== 'plate') return;
        e.preventDefault(); e.stopPropagation();
        isDrawing = true;
        const rect = staticImage.getBoundingClientRect();
        startX = Math.round(e.clientX - rect.left);
        startY = Math.round(e.clientY - rect.top);
        selectionBox.style.display = 'block';
        selectionBox.style.left = `${startX}px`;
        selectionBox.style.top = `${startY}px`;
        selectionBox.style.width = '0px';
        selectionBox.style.height = '0px';
        staticImageContainer.setPointerCapture?.(e.pointerId);
      }

      function onSelectMove(e) {
        if (!isPrimaryPointer(e) || toolMode !== 'plate') return;
        e.preventDefault(); e.stopPropagation();
        const rect = staticImage.getBoundingClientRect();
        currentX = Math.round(e.clientX - rect.left);
        currentY = Math.round(e.clientY - rect.top);
        const width = currentX - startX;
        const height = currentY - startY;
        selectionBox.style.left = `${width > 0 ? startX : currentX}px`;
        selectionBox.style.top = `${height > 0 ? startY : currentY}px`;
        selectionBox.style.width = `${Math.abs(width)}px`;
        selectionBox.style.height = `${Math.abs(height)}px`;
      }

      function onSelectEnd(e) {
        if (!isPrimaryPointer(e) || toolMode !== 'plate') return;
        isDrawing = false;
        staticImageContainer.releasePointerCapture?.(e.pointerId);
        selectionBox.style.display = 'none';

        const dx = Math.abs(currentX - startX);
        const dy = Math.abs(currentY - startY);
        if (dx < dragThreshold && dy < dragThreshold) { setOverlayInteractive(true); return; }

        const displayW = staticImage.clientWidth;
        const displayH = staticImage.clientHeight;
        const actualW = videoEl.videoWidth;
        const actualH = videoEl.videoHeight;
        const scaleX = actualW / displayW;
        const scaleY = actualH / displayH;
        const x1 = Math.min(startX, currentX), y1 = Math.min(startY, currentY);
        const x2 = Math.max(startX, currentX), y2 = Math.max(startY, currentY);

        finalCropCoords = {
          x1: Math.round(x1 * scaleX),
          y1: Math.round(y1 * scaleY),
          x2: Math.round(x2 * scaleX),
          y2: Math.round(y2 * scaleY)
        };
        confirmCropArea();
      }

      function confirmCropArea() {
        const cropW = finalCropCoords.x2 - finalCropCoords.x1;
        const cropH = finalCropCoords.y2 - finalCropCoords.y1;
        if (cropW <= 0 || cropH <= 0) return;

        const c = document.createElement('canvas'); c.width = cropW; c.height = cropH;
        const ctx = c.getContext('2d');
        try {
          ctx.drawImage(videoEl, finalCropCoords.x1, finalCropCoords.y1, cropW, cropH, 0, 0, cropW, cropH);
          plateImageInMemory = new Image();
          plateImageInMemory.src = c.toDataURL('image/jpeg');

          plateImg.src = plateImageInMemory.src;
          plateImg.style.display = 'block';
          const plateBar = container.querySelector('.plate-preview');
          if (plateBar?.style) plateBar.style.display = 'flex';

          plateImageInMemory.onload = () => {
            drawOverlayContent();
            restorePlatePreviewIfAny();
            setOverlayInteractive(true);
            setTool(lastNonPlateTool || 'shape');
          };
        } catch (e) {
          console.error('裁切失敗：', e);
        }
      }

      function restorePlatePreviewIfAny() {
        const plateBar = container.querySelector('.plate-preview');
        if (!plateBar) return;
        if (plateImageInMemory) {
          plateImg.src = plateImageInMemory.src;
          plateImg.style.display = 'block';
          plateBar.style.display = 'flex';
          drawOverlayContent?.();
        } else {
          plateImg.style.display = 'none';
          plateBar.style.display = 'none';
        }
      }

      function clearPlateCrop() {
        plateImageInMemory = null;
        finalCropCoords = {};
        if (plateImg) {
          plateImg.removeAttribute('src');
          plateImg.style.display = 'none';
        }
        const plateBar = container.querySelector('.plate-preview');
        if (plateBar) plateBar.style.display = 'none';
        drawOverlayContent?.();
        setOverlayInteractive(true);
      }

      /* ===== Overlay Repaint ===== */
      function drawOverlayContent() {
        const ctx = drawingOverlay.getContext('2d');
        ctx.clearRect(0, 0, drawingOverlay.width, drawingOverlay.height);
        if (mosaicItems.length) drawMosaicOverlay(ctx);
        if (drawnShapes.length > 0) {
          const displayW = staticImage.clientWidth;
          const displayH = staticImage.clientHeight;
          drawAllUserShapes(ctx, displayW, displayH, true);
        }
        if (textItems.length) {
          ctx.save();
          textItems.forEach(t => {
            ctx.font = t.font || `bold ${getTextSize()}px sans-serif`;
            ctx.textAlign = t.align || 'left';
            ctx.textBaseline = t.baseline || 'alphabetic';
            if (t.stroke) { ctx.strokeStyle = t.stroke; ctx.lineWidth = 2; ctx.strokeText(t.text, t.x, t.y); }
            ctx.fillStyle = t.fill || getTextColor();
            ctx.fillText(t.text, t.x, t.y);
          });
          ctx.restore();
        }
        if (plateImageInMemory) drawPlateOnCanvas(ctx, drawingOverlay.width, drawingOverlay.height, true);
      }

      /* ===== Plate Paste ===== */
      function drawPlateOnCanvas(ctx, targetW, targetH, isOverlay = false) {
        if (!plateImageInMemory) return;
        const position = platePositionSelect.value || 'bottomRight';
        const scalePercent = (Number(plateScaleInput.value) || 30) / 100;
        const margin = 16;
        const ow = plateImageInMemory.width, oh = plateImageInMemory.height;
        let w = targetW * scalePercent;
        let h = (w / ow) * oh;
        let x, y;
        switch (position) {
          case 'topRight':   x = targetW - w - margin; y = margin; break;
          case 'topLeft':    x = margin; y = margin; break;
          case 'bottomLeft': x = margin; y = targetH - h - margin; break;
          case 'bottomRight':
          default:           x = targetW - w - margin; y = targetH - h - margin; break;
        }

        // Draw image first, then stroke border
        ctx.drawImage(plateImageInMemory, x, y, w, h);
        ctx.save();
        ctx.strokeStyle = '#e53935';
        ctx.lineWidth = isOverlay ? 3 : 4;
        ctx.strokeRect(x, y, w, h);
        ctx.restore();
      }

      /* ===== Shape Drawing (Rect / Circle) ===== */
      function startUserDrawing(e) {
        if (!isPrimaryPointer(e)) return;
        e.preventDefault();
        isDrawing = true;
        const rect = drawingOverlay.getBoundingClientRect();
        startX = e.clientX - rect.left;
        startY = e.clientY - rect.top;
        currentShape = {
          type: drawingShapeSelect?.value || 'rectangle',
          thickness: Number(lineThicknessInput?.value || 5),
          startX, startY, endX: startX, endY: startY, angle: 0, width: 0, height: 0
        };
      }

      function drawUserMoving(e) {
        if (!isDrawing || !currentShape) return;
        e.preventDefault();
        const rect = drawingOverlay.getBoundingClientRect();
        currentX = e.clientX - rect.left;
        currentY = e.clientY - rect.top;
        const dx = currentX - startX;
        const dy = currentY - startY;

        if (rotationCheckbox?.checked) {
          currentShape.width  = Math.sqrt(dx*dx + dy*dy);
          currentShape.height = currentShape.width * 0.5;
          currentShape.angle  = Math.atan2(dy, dx);
        } else {
          currentShape.width  = Math.abs(dx);
          currentShape.height = Math.abs(dy);
          currentShape.angle  = 0;
        }
        currentShape.endX = currentX;
        currentShape.endY = currentY;
        drawOverlayContent();
        const ctx = drawingOverlay.getContext('2d');
        drawShape(ctx, currentShape, 1, 1);
      }

      function stopUserDrawing() {
        if (!isDrawing || !currentShape) return;
        isDrawing = false;
        if (currentShape.width > dragThreshold && currentShape.height > dragThreshold) drawnShapes.push(currentShape);
        currentShape = null;
        drawOverlayContent();
      }

      function clearAllDrawings() {
        drawnShapes = [];
        textItems = [];
        mosaicItems = [];
        drawOverlayContent();
      }

      function drawShape(ctx, shape, scaleX, scaleY) {
        ctx.strokeStyle = '#e53935';
        ctx.lineWidth = shape.thickness * scaleX;
        ctx.save();
        const cx = (shape.startX + (shape.endX - shape.startX) / 2) * scaleX;
        const cy = (shape.startY + (shape.endY - shape.startY) / 2) * scaleY;
        ctx.translate(cx, cy);
        ctx.rotate(shape.angle);
        if (shape.type === 'rectangle') {
          const w = shape.width * scaleX;
          const h = shape.height * scaleY;
          ctx.strokeRect(-w / 2, -h / 2, w, h);
        } else if (shape.type === 'circle') {
          const rx = (shape.width / 2) * scaleX;
          const ry = (shape.height / 2) * scaleY;
          ctx.scale(1, ry / rx);
          ctx.beginPath(); ctx.arc(0, 0, rx, 0, Math.PI * 2); ctx.stroke();
        }
        ctx.restore();
      }

      function drawAllUserShapes(ctx, finalW, finalH, isOverlay = false) {
        if (!drawnShapes.length) return;
        let scaleX = 1, scaleY = 1;
        if (!isOverlay) {
          const displayW = staticImage.clientWidth || drawingOverlay.width || finalW;
          const displayH = staticImage.clientHeight || drawingOverlay.height || finalH;
          scaleX = finalW / displayW;
          scaleY = finalH / displayH;
        }
        drawnShapes.forEach(s => drawShape(ctx, s, scaleX, scaleY));
      }

      /* ===== Text Editing ===== */
      function toOverlayCoord(e) {
        const rect = drawingOverlay.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }

      function hitTextItem(x, y) {
        const ctx = drawingOverlay.getContext('2d');
        for (let i = textItems.length - 1; i >= 0; i--) {
          const t = textItems[i];
          ctx.save();
          ctx.font = t.font || `bold ${getTextSize()}px sans-serif`;
          const m = ctx.measureText(t.text || '');
          const w = m.width;
          const h = (m.actualBoundingBoxAscent || 12) + (m.actualBoundingBoxDescent || 4);
          const left = t.align === 'center' ? t.x - w / 2 : (t.align === 'right' ? t.x - w : t.x);
          const top  = t.y - h;
          ctx.restore();
          if (x >= left && x <= left + w && y >= top && y <= top + h) return t;
        }
        return null;
      }

      function onTextPointerDown(e) {
        if (activeTextEditor) return;
        if (e.detail > 1) return; // 避免連點干擾
        const pt = toOverlayCoord(e);              // ← 區域變數集中在前
        const x = pt.x, y = pt.y;
        const hit = hitTextItem(x, y);
        if (hit) {
          // ★ 命中文本 → 準備拖曳（是否進編輯由 pointerUp 判定）
          isTextDragging = true;
          dragText = hit;
          dragStartX = x;  dragStartY = y;
          dragOrigX  = hit.x; dragOrigY  = hit.y;
          drawingOverlay.setPointerCapture?.(e.pointerId);
          e.preventDefault(); e.stopPropagation();
          return;
        }
        // 未命中文本 → 直接建立新文字
        openTextEditor({
          mode: 'create',
          seed: {
            x, y,
            text: '',
            font: `bold ${getTextSize()}px sans-serif`,
            fill: getTextColor(),
            align: 'left',
            baseline: 'alphabetic'
          }
        });
      }

      function onTextPointerMove(e) {
        // 未在拖曳：可選擇顯示游標提示
        if (!isTextDragging || !dragText) {
          // 可選：命中即顯示移動游標，否則顯示文字游標
          const pt = toOverlayCoord(e);
          const x = pt.x, y = pt.y;
          drawingOverlay.style.cursor = hitTextItem(x, y) ? 'move' : 'text';
          return;
        }
        // 正在拖曳：更新目標文字位置
        const pt = toOverlayCoord(e);
        const x = pt.x, y = pt.y;
        const dx = x - dragStartX;
        const dy = y - dragStartY;
        dragText.x = dragOrigX + dx;
        dragText.y = dragOrigY + dy;
        drawOverlayContent();
      }

      function onTextPointerUp(e) {
        if (!isTextDragging) return;
        drawingOverlay.releasePointerCapture?.(e.pointerId);
        const pt = toOverlayCoord(e);
        const x = pt.x, y = pt.y;
        const moved = Math.hypot(x - dragStartX, y - dragStartY) > textDragThreshold;
        const item = dragText;
        // 重置拖曳狀態
        isTextDragging = false;
        dragText = null;
        if (!moved) {
          // 幾乎沒移動 → 視為點一下 → 進入編輯
          return openTextEditor({ mode: 'edit', item });
        }
        // 有移動 → 位置已經在 move 階段更新，這裡只需重繪
        drawOverlayContent();
      }

      function openTextEditor({ mode, seed, item }) {
        if (activeTextEditor) return;
        const rect = drawingOverlay.getBoundingClientRect();
        const isEdit = mode === 'edit';
        const x = isEdit ? item.x : seed.x;
        const y = isEdit ? item.y : seed.y;
        const font = isEdit ? item.font : (seed.font || `bold ${getTextSize()}px sans-serif`);
        const fill = isEdit ? item.fill : (seed.fill || getTextColor());
        const initialText = isEdit ? (item.text || '') : (seed.text || '');
        editingTextId = isEdit ? item.id : null;
        const vx = rect.left + x;
        const vy = rect.top + y;
        const sx = window.scrollX, sy = window.scrollY;
        const keepScroll = () => window.scrollTo(sx, sy);
        const onScrollLock = () => keepScroll();
        const input = document.createElement('input');
        const mctx = document.createElement('canvas').getContext('2d');
        mctx.font = font;
        const sampleText = (initialText && initialText.trim().length > 0) ? initialText : 'M';
        const metrics = mctx.measureText(sampleText);
        const ascent  = metrics.actualBoundingBoxAscent || (parseInt(font, 10) || getTextSize());
        const descent = metrics.actualBoundingBoxDescent || 0;
        const textW   = mctx.measureText(initialText || '').width;
        const align    = isEdit ? (item.align    || 'left')       : (seed.align    || 'left');
        const baseline = isEdit ? (item.baseline || 'alphabetic') : (seed.baseline || 'alphabetic');
        let topPx = vy - ascent - 5;
        let leftPx = vx;
        input.type = 'text';
        input.value = initialText;
        input.placeholder = isEdit ? '' : '輸入文字';
        if (align === 'center') leftPx = vx - textW / 2;
        if (align === 'right')  leftPx = vx - textW;
        input.style.position = 'fixed';
        input.style.left = `${leftPx}px`;
        input.style.top  = `${topPx}px`;
        input.style.font = font;
        input.style.color = fill;
        input.style.border = '0';
        input.style.padding = '0 2px';
        input.style.lineHeight = `${Math.ceil(ascent + descent)}px`;
        input.style.background = '#fff';
        input.style.zIndex = '9999';
        input.style.borderRadius = '4px';
        input.style.maxWidth = '60vw';
        input.style.textAlign = align;
        input.style.boxSizing = 'content-box';
        input.autocapitalize = 'off';
        input.autocomplete = 'off';
        input.autocorrect = 'off';
        input.spellcheck = false;
        input.setAttribute('inputmode', 'text');

        document.body.appendChild(input);
        window.addEventListener('scroll', onScrollLock, { passive: false });
        activeTextEditor = input;

        const onOutsideTap = (ev) => {
          if (ev.target !== input) { ev.preventDefault?.(); ev.stopPropagation?.(); cancelAndFinish(); }
        };
        drawingOverlay.addEventListener('pointerdown', onOutsideTap, true);
        staticImageContainer?.addEventListener('pointerdown', onOutsideTap, true);
        document.addEventListener('pointerdown', onOutsideTap, true);

        setTimeout(() => { input.focus(); input.select(); }, 0);

        const onBlur = () => finish(true);
        input.addEventListener('blur', onBlur);

        let finishing = false;
        let finished = false;
        function cleanupCommon() {
          if (finishing) return; finishing = true;
          window.removeEventListener('scroll', onScrollLock);
          drawingOverlay.removeEventListener('pointerdown', onOutsideTap, true);
          staticImageContainer?.removeEventListener('pointerdown', onOutsideTap, true);
          document.removeEventListener('pointerdown', onOutsideTap, true);
          try { document.body.removeChild(input); } catch {}
          activeTextEditor = null;
        }

        function cancelAndFinish() {
          // 若有輸入文字，視為送出；否則視為取消
          const hasText = ((input.value || '').trim().length > 0);
          // 先移除 blur 監聽，避免外點 → 移除 input → blur 再次觸發 finish 的重入
          input.removeEventListener('blur', onBlur);
          // 交給 finish 統一處理（finish 內會負責 cleanup / 狀態變更 / 重繪）
          finish(hasText);
        }

        function finish(commit) {
          if (finished) return; finished = true;
          cleanupCommon();
          window.scrollTo(sx, sy);
          const newText = (input.value || '').trim();
          if (!commit) { editingTextId = null; return; }
          if (isEdit) {
            const idx = textItems.findIndex(t => t.id === editingTextId);
            if (newText.length === 0) { if (idx >= 0) textItems.splice(idx, 1); }
            else if (idx >= 0) { textItems[idx].text = newText; textItems[idx].font = font; textItems[idx].fill = fill; }
            editingTextId = null;
            drawOverlayContent();
            return;
          }
          if (newText.length === 0) { editingTextId = null; return; }
          textItems.push({ id: crypto.randomUUID(), x, y, text: newText, font, fill, align: seed.align || 'left', baseline: seed.baseline || 'alphabetic' });
          editingTextId = null;
          drawOverlayContent();
        }
        input.addEventListener('keydown', (e) => {
          const isEnter = (e.key === 'Enter');
          const isEsc   = (e.key === 'Escape');
          if (!isEnter && !isEsc) return;
          input.removeEventListener('blur', onBlur);
          if (isEnter) { finish(true); return;}
          if (isEsc) { input.value = ''; finish(false); return; }
        });
      }

      /* ===== Mosaic ===== */
      function startMosaic(e, block) {
        e.preventDefault(); e.stopPropagation();
        isMosaicDrawing = true;
        const rect = drawingOverlay.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        mosaicCurrent = { startX: x, startY: y, endX: x, endY: y, rect: { x, y, w: 0, h: 0 }, block: block || 12 };
        drawOverlayContent();
        const ctx = drawingOverlay.getContext('2d');
        ctx.save(); ctx.strokeStyle = '#ffcc00'; ctx.lineWidth = 2; ctx.setLineDash([6, 4]); ctx.strokeRect(x, y, 1, 1); ctx.restore();
      }

      function drawMosaicMoving(e) {
        e.preventDefault(); e.stopPropagation();
        if (!isMosaicDrawing || !mosaicCurrent) return;
        const rect = drawingOverlay.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        mosaicCurrent.endX = x; mosaicCurrent.endY = y;
        const w = Math.abs(x - mosaicCurrent.startX);
        const h = Math.abs(y - mosaicCurrent.startY);
        const rx = Math.min(mosaicCurrent.startX, x);
        const ry = Math.min(mosaicCurrent.startY, y);
        mosaicCurrent.rect = { x: rx, y: ry, w, h };
        drawOverlayContent();
        const ctx = drawingOverlay.getContext('2d');
        ctx.save(); ctx.strokeStyle = '#ffcc00'; ctx.lineWidth = 2; ctx.setLineDash([6, 4]); ctx.strokeRect(rx, ry, w, h); ctx.restore();
      }

      function stopMosaic(e) {
        e?.preventDefault?.(); e?.stopPropagation?.();
        if (!isMosaicDrawing || !mosaicCurrent) return;
        isMosaicDrawing = false;
        const { rect, block } = mosaicCurrent;
        if (rect.w > 4 && rect.h > 4) mosaicItems.push({ id: crypto.randomUUID(), rect: { ...rect }, block });
        mosaicCurrent = null;
        drawOverlayContent();
      }

      function drawMosaicOverlay(ctx) {
        if (!staticImage || staticImage.naturalWidth === 0) return;
        const ow = drawingOverlay.width, oh = drawingOverlay.height;
        const scaleX = staticImage.naturalWidth / ow;
        const scaleY = staticImage.naturalHeight / oh;
        mosaicItems.forEach(mz => {
          const { x, y, w, h } = mz.rect;
          if (w <= 0 || h <= 0) return;
          const sx = Math.max(0, Math.round(x * scaleX));
          const sy = Math.max(0, Math.round(y * scaleY));
          const sw = Math.max(1, Math.round(w * scaleX));
          const sh = Math.max(1, Math.round(h * scaleY));
          const off = document.createElement('canvas');
          off.width = Math.max(1, Math.floor(sw / mz.block));
          off.height = Math.max(1, Math.floor(sh / mz.block));
          const octx = off.getContext('2d');
          octx.drawImage(staticImage, sx, sy, sw, sh, 0, 0, off.width, off.height);
          ctx.save();
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(off, 0, 0, off.width, off.height, x, y, w, h);
          ctx.restore();
        });
      }

      function applyMosaicOnFinal(ctxFinal) {
        if (!mosaicItems.length) return;
        const c = ctxFinal.canvas;
        const finalW = c.width, finalH = c.height;
        const displayW = staticImage.clientWidth || drawingOverlay.width || finalW;
        const displayH = staticImage.clientHeight || drawingOverlay.height || finalH;
        const scaleX = finalW / displayW, scaleY = finalH / displayH;

        mosaicItems.forEach(mz => {
          const { x, y, w, h } = mz.rect;
          const fx = Math.round(x * scaleX);
          const fy = Math.round(y * scaleY);
          const fw = Math.max(1, Math.round(w * scaleX));
          const fh = Math.max(1, Math.round(h * scaleY));
          const tmp = document.createElement('canvas'); tmp.width = fw; tmp.height = fh;
          const tctx = tmp.getContext('2d'); tctx.drawImage(c, fx, fy, fw, fh, 0, 0, fw, fh);
          const small = document.createElement('canvas');
          small.width = Math.max(1, Math.floor(fw / mz.block));
          small.height = Math.max(1, Math.floor(fh / mz.block));
          const sctx = small.getContext('2d');
          sctx.drawImage(tmp, 0, 0, fw, fh, 0, 0, small.width, small.height);
          ctxFinal.save();
          ctxFinal.imageSmoothingEnabled = false;
          ctxFinal.drawImage(small, 0, 0, small.width, small.height, fx, fy, fw, fh);
          ctxFinal.restore();
        });
      }

      /* ===== Final Image Generation ===== */
      function generateReportImage() {
        if (!videoEl?.src) return;
        videoEl.pause();
        finalCanvas.width = videoEl.videoWidth;
        finalCanvas.height = videoEl.videoHeight;
        const ctx = finalCanvas.getContext('2d');
        // Base frame
        ctx.drawImage(videoEl, 0, 0, finalCanvas.width, finalCanvas.height);
        // Mosaic on final
        applyMosaicOnFinal(ctx);
        // Shapes
        drawAllUserShapes(ctx, finalCanvas.width, finalCanvas.height, false);
        // Plate
        drawPlateOnCanvas(ctx, finalCanvas.width, finalCanvas.height, false);
        // Text
        if (textItems.length) {
          const displayW = staticImage.clientWidth || drawingOverlay.width || finalCanvas.width;
          const displayH = staticImage.clientHeight || drawingOverlay.height || finalCanvas.height;
          const scaleX = finalCanvas.width / displayW, scaleY = finalCanvas.height / displayH;
          ctx.save();
          textItems.forEach(t => {
            const sizeMatch = (t.font || '').match(/(\d+)px/i);
            const baseSize = sizeMatch ? Number(sizeMatch[1]) : 18;
            const scaled = Math.max(8, Math.round(baseSize * ((scaleX + scaleY) / 2)));
            const fontFamily = (t.font || `bold ${baseSize}px sans-serif`).replace(/\d+px/i, `${scaled}px`);
            const fx = Math.round(t.x * scaleX);
            const fy = Math.round(t.y * scaleY);
            ctx.font = fontFamily;
            ctx.textAlign = t.align || 'left';
            ctx.textBaseline = t.baseline || 'alphabetic';
            if (t.stroke) { ctx.strokeStyle = t.stroke; ctx.lineWidth = 2; ctx.strokeText(t.text, fx, fy); }
            ctx.fillStyle = t.fill || '#ff2d55';
            ctx.fillText(t.text, fx, fy);
          });
          ctx.restore();
        }
        const url = finalCanvas.toDataURL('image/jpeg');
        pushGeneratedItem(url);
      }

      /* ===== Preview ===== */
      function showPreview(url) {
        if (!previewLayer) {
          previewLayer = document.createElement('div');
          Object.assign(previewLayer.style, {
            position: 'fixed', top: '50%', left: '50%', transform: 'translate(-50%,-50%)',
            maxWidth: '90vw', maxHeight: '90vh', boxShadow: '0 5px 15px rgba(0,0,0,.3)',
            border: '1px solid var(--border)', zIndex: '9999', display: 'none', background: '#0e0f12',
            padding: '8px', borderRadius: '8px'
          });
          const img = document.createElement('img'); img.style.maxWidth = '100%'; img.style.maxHeight = '80vh'; img.style.borderRadius = '4px';
          previewLayer.appendChild(img);
          document.body.appendChild(previewLayer);
          previewLayer.addEventListener('click', hidePreview);
        }
        const img = previewLayer.querySelector('img'); img.src = url;
        previewLayer.style.display = 'block';
      }

      function hidePreview() { if (previewLayer) previewLayer.style.display = 'none'; }

      /* ===== Exports ===== */
      return { init, loadSnapshot, isReady };
    })();

    // 在所有函式宣告之後加上這段「啟動即更新」
    requestAnimationFrame(() => {
      // 第 1 帧：DOM 已排版完成，rail 有正確寬度
      updateSelectionBar();
    });
    // 再保險一帧（某些字型/面板異動會影響初始排版）
    requestAnimationFrame(() => updateSelectionBar());
  </script>
    <!-- 從外部載入違規項目選單 -->
  <script src="./violation_list.js"></script>
  
  <footer style="font-size: 12px; opacity: 0.7; text-align:center; margin-top: 40px;">
    本網站使用了 FFmpeg（LGPL v2.1+）之 WebAssembly 核心。
    FFmpeg 原始碼可從官方取得： 
    <a href="https://github.com/FFmpeg/FFmpeg" target="_blank">https://github.com/FFmpeg/FFmpeg</a><br>
    本網站未修改 FFmpeg 核心，僅透過 WebAssembly 作為函式庫使用。
  </footer>
</body>
</html>